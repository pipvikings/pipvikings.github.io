<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="指针的定义#指针的定义：指针是存储对象内存地址的变量
C和C&#43;&#43;指针的用法有：
分配堆内存的新对象 向一个函数传递另外一个函数 迭代数组或其他数据结构中的元素 在C风格的编程中，裸指针适用于上述三种描述。但是裸指针是导致很多问题的元凶，因此除非在有显著性能优势且清楚在删除对象时哪个指针有最终的所有权时，不要用裸指针。&mdash;-msdn
现代C&#43;&#43;提供智能指针来负责分配对象、迭代器和遍历数据结构们，以及传递函数时使用的lambda表达式。
裸指针#指针是变量，它存储对象在内存中的地址，它也用于访问对象。裸指针的定义是：生命周期不受封装对象控制的指针，这不同于智能指针。裸指针可以被赋值为另一个非指针变量的地址，或者可以被赋值为nullptr，未被赋值的裸指针随机被赋值一个地址。 指针可以被取消引用（dereference），返回它指向的对象值。
int* p = nullptr; // declare pointer and initialize it// so that it doesn&#39;t store a random addressint i = 5;p = &amp;i; // assign pointer to address of objectint j = *p; // dereference p to retrieve the value at its address 一个指针可以指向一个有类型的对象或者void。当一个程序在heap分配对象时，它接收这个对象的地址（以指针的形式），如此的指针叫做owing pointer，一个owing pointer（or a copy of it），在不再需要那个heap object的时候，必须显式的free掉这个指针。否则就会内存泄漏，即此内存的地址没法给任何其他的程序去用了。用new分配出来的内存必须搭配delete或者delete[]。
MyClass* mc = new MyClass(); // allocate object on the heapmc-&gt;print(); // access class memberdelete mc; // delete object (please don&#39;t forget!">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="裸指针和其修饰字" />
<meta property="og:description" content="指针的定义#指针的定义：指针是存储对象内存地址的变量
C和C&#43;&#43;指针的用法有：
分配堆内存的新对象 向一个函数传递另外一个函数 迭代数组或其他数据结构中的元素 在C风格的编程中，裸指针适用于上述三种描述。但是裸指针是导致很多问题的元凶，因此除非在有显著性能优势且清楚在删除对象时哪个指针有最终的所有权时，不要用裸指针。&mdash;-msdn
现代C&#43;&#43;提供智能指针来负责分配对象、迭代器和遍历数据结构们，以及传递函数时使用的lambda表达式。
裸指针#指针是变量，它存储对象在内存中的地址，它也用于访问对象。裸指针的定义是：生命周期不受封装对象控制的指针，这不同于智能指针。裸指针可以被赋值为另一个非指针变量的地址，或者可以被赋值为nullptr，未被赋值的裸指针随机被赋值一个地址。 指针可以被取消引用（dereference），返回它指向的对象值。
int* p = nullptr; // declare pointer and initialize it// so that it doesn&#39;t store a random addressint i = 5;p = &amp;i; // assign pointer to address of objectint j = *p; // dereference p to retrieve the value at its address 一个指针可以指向一个有类型的对象或者void。当一个程序在heap分配对象时，它接收这个对象的地址（以指针的形式），如此的指针叫做owing pointer，一个owing pointer（or a copy of it），在不再需要那个heap object的时候，必须显式的free掉这个指针。否则就会内存泄漏，即此内存的地址没法给任何其他的程序去用了。用new分配出来的内存必须搭配delete或者delete[]。
MyClass* mc = new MyClass(); // allocate object on the heapmc-&gt;print(); // access class memberdelete mc; // delete object (please don&#39;t forget!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pipvkings.github.io/docs/example/table-of-contents/rawp/" /><meta property="article:section" content="docs" />


<title>裸指针和其修饰字 | 首頁介紹</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.a1bc3f1d714233dbb3581a7510c0be58c1aadad42dcdfaaecec1aaa38023c9e2.css" integrity="sha256-obw/HXFCM9uzWBp1EMC&#43;WMGq2tQtzfquzsGqo4AjyeI=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.f0c6fac7200a71399e3465a133f38930434c055e2ca71404d6ad0a7d22d66c03.js" integrity="sha256-8Mb6xyAKcTmeNGWhM/OJMENMBV4spxQE1q0KfSLWbAM=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>首頁介紹</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>Contents Post</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/after-school/" class="">After School</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/after-school/meaning-of-work/" class="">上班的意義</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/after-school/2023scc/" class="">个人数据的标准合同条款</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/" class="">At School</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/operator-overloading/" class="">A Review at Operator Overloading</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/cppio/" class="">C&#43;&#43; IO的简单复习</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/cpp_thread/" class="">C&#43;&#43;的线程同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/lseek/" class="">lseek和空洞文件</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/shared_p/" class="">shared_ptr的用例</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/uniq_p/" class="">unique_ptr的用例</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/operator-overloading-zh/" class="">对操作符重载的学习</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/os-review/" class="">操作系统中的进程和锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/smart_pointer/" class="">智能指针</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/type-casting-zh/" class="">浅谈C&#43;&#43;中的类型转换</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/sliding_windows_prot/" class="">滑动窗口</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/rawp/" class="active">裸指针和其修饰字</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>裸指针和其修饰字</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h2 id="指针的定义">
  指针的定义
  <a class="anchor" href="#%e6%8c%87%e9%92%88%e7%9a%84%e5%ae%9a%e4%b9%89">#</a>
</h2>
<p>指针的定义：指针是存储对象内存地址的变量</p>
<p>C和C++指针的用法有：</p>
<ul>
<li>分配堆内存的新对象</li>
<li>向一个函数传递另外一个函数</li>
<li>迭代数组或其他数据结构中的元素</li>
</ul>
<p>在C风格的编程中，裸指针适用于上述三种描述。但是裸指针是导致很多问题的元凶，因此除非在有显著性能优势且清楚在删除对象时哪个指针有最终的所有权时，不要用裸指针。&mdash;-msdn</p>
<p>现代C++提供智能指针来负责分配对象、迭代器和遍历数据结构们，以及传递函数时使用的lambda表达式。</p>
<h2 id="裸指针">
  裸指针
  <a class="anchor" href="#%e8%a3%b8%e6%8c%87%e9%92%88">#</a>
</h2>
<ul>
<li>指针是变量，它存储对象在内存中的地址，它也用于访问对象。<strong>裸指针的定义是：生命周期不受封装对象控制的指针</strong>，这不同于智能指针。裸指针可以被赋值为另一个非指针变量的地址，或者可以被赋值为<code>nullptr</code>，未被赋值的裸指针随机被赋值一个地址。</li>
</ul>
<p>指针可以被取消引用（dereference），返回它指向的对象值。</p>
<pre tabindex="0"><code>int* p = nullptr; // declare pointer and initialize it
                      // so that it doesn&#39;t store a random address
int i = 5;
p = &amp;i; // assign pointer to address of object
int j = *p; // dereference p to retrieve the value at its address
</code></pre><p>一个指针可以指向一个有类型的对象或者<code>void</code>。当一个程序在heap分配对象时，它接收这个对象的地址（以指针的形式），如此的指针叫做owing pointer，一个owing pointer（or a copy of it），在不再需要那个heap object的时候，必须显式的free掉这个指针。否则就会内存泄漏，即此内存的地址没法给任何其他的程序去用了。用<code>new</code>分配出来的内存必须搭配<code>delete</code>或者<code>delete[]</code>。</p>
<pre tabindex="0"><code>MyClass* mc = new MyClass(); // allocate object on the heap
mc-&gt;print(); // access class member
delete mc; // delete object (please don&#39;t forget!)
</code></pre><p>一个指针，假设没有被声明为<code>const</code>指针，那么就可以自增或者自减到内存中的其他位置，这种操作叫做指针的算术运算。在C语言中，数组的迭代（或其他数据结构）会用到这种运算。<code>const</code>指针不能变更到内存的其他位置。
在六十四位的操作系统中，指针就有六十四个bit，一个指针的尺寸决定于它的可寻址空间有多少。所有指针的拷贝都指向同一个内存地址，指针（同引用）在C++程序中经常被用于传递对象的地址（而不是传递整个大对象），当定义一个函数的时候，规定指针参数为<code>const</code>，除非你想改这个对象，但是实际上，常引用比常量指针更常用于传递参数，除非此对象的值是<code>nullptr</code>。</p>
<p>指针和数组有很大的关联，当一个数组在函数传参的时候，它传递的是第一个元素的地址</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;

void func(int arr[], int length)
{
    // returns pointer size. not useful here.
    size_t test = sizeof(arr);

    for(int i = 0; i &lt; length; ++i)
    {
        std::cout &lt;&lt; arr[i] &lt;&lt; &#34; &#34;;
    }
}

int main()
{

    int i[5]{ 1,2,3,4,5 };
    // sizeof(i) = total bytes
    int j = sizeof(i) / sizeof(i[0]);
    func(i,j);
}
</code></pre><p><code>sizeof</code>操作符返回数组有几个bytes，除以一个元素的<code>sizeof</code>就是数组的长度，当一个数组被当成参数的时候，会变成一个指针，<code>sizeof</code>一个指针对于x86机器来说返回四个byte，对于x64机器来说返回8个byte。
指针的算数运算可以用在非<code>const</code>指针让它们指向其它内存地址，指针可以用<code>++</code>, <code>+=</code>, <code>-=</code>, <code>--</code>来自增或者自减，这种方法在没类型的数据面前特别有用，比如<code>void*</code>指针会自增一个<code>byte</code>，一个有类型的指针按照它指向的值的 <code>sizeof</code>自增。</p>
<h2 id="pointers-to-functions">
  Pointers to functions
  <a class="anchor" href="#pointers-to-functions">#</a>
</h2>
<p><strong>允许函数被传递到其他函数中，在C语言中称作call backs，现代 C++ 转而使用lambda表达式。</strong></p>
<h2 id="void-pointer">
  <code>void*</code> pointer
  <a class="anchor" href="#void-pointer">#</a>
</h2>
<p>A pointer to void simply points to a raw memory location. Sometimes it&rsquo;s necessary to use <code>void*</code> pointers, for example when passing between C++ code and C functions.</p>
<p>When a typed pointer is cast to a void pointer, the contents of the memory location are unchanged. However, the type information is lost, so that you can&rsquo;t do increment or decrement operations. A memory location can be cast, for example, from <code>MyClass*</code> to <code>void*</code> and back again to <code>MyClass*</code>. Such operations are inherently error-prone and require great care to avoid errors.</p>
<p><strong>Modern C++ discourages the use of void pointers in almost all circumstances.</strong></p>
<h2 id="pointer-to-function">
  pointer to function
  <a class="anchor" href="#pointer-to-function">#</a>
</h2>
<p>In C-style programming, function pointers are used primarily to pass functions to other functions. This technique allows the caller to customize the behavior of a function without modifying it. In modern C++, <strong>lambda expressions provide the same capability with greater type safety and other advantages.</strong></p>
<p>A function pointer declaration specifies the signature that the pointed-to function must have:</p>
<pre tabindex="0"><code>// Declare pointer to any function that...

// ...accepts a string and returns a string
string (*g)(string a);

// has no return value and no parameters
void (*x)();

// ...returns an int and takes three parameters
// of the specified types
int (*i)(int i, string s, double d);
</code></pre><h2 id="const和volatile">
  <code>const</code>和<code>volatile</code>
  <a class="anchor" href="#const%e5%92%8cvolatile">#</a>
</h2>
<p><code>const</code>和<code>volatile</code>关键字改变了系统对待指针的方式，<code>const</code>指针规定在初始化之后其值不能被修改，也就是说指针被保护以至于不能被修改。<code>volatile</code>关键字规定了值可以被其他程序改变的变量（多线程？）因此，<code>volatile</code>关键字用于声明shared memory中可以被多线程修改的或者全局的数据（用于沟通的、用于interrupt service routines的）
当一个变量被声明为<code>volatile</code>时，每一次程序要访问这个变量时，编译器都从内存重新读取它的值，这样显著的减少了编译器优化，however，当变量的状态可以不寻常的改变时，这是唯一允许这个程序可以正常运行的方式。<a href="https://www.cnblogs.com/chio/archive/2007/11/24/970632.html">请参阅这个博客</a>和<a href="https://learn.microsoft.com/en-us/cpp/cpp/const-and-volatile-pointers?view=msvc-160">这个博客</a></p>
<p>To declare the object pointed to by the pointer as const or volatile, use a declaration of the form:
要将指针指向的对象声明为<code>const</code>或<code>volatile</code>，请使用以下形式的声明：</p>
<pre tabindex="0"><code>const char *cpch;
volatile char *vpch;
</code></pre><p>To declare the value of the pointer — that is, the actual address stored in the pointer — as <code>const</code> or <code>volatile</code>, use a declaration of the form:</p>
<p>声明指针的值-也就是说，实际的地址存在了指针里而不是指针指向的对象里时，用这个声明。</p>
<pre tabindex="0"><code>char * const pchc;
char * volatile pchv;
</code></pre><blockquote>
<p>两种声明↑，留意</p>
</blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  
</body>
</html>












