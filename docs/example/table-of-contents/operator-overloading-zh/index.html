<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="A Review at Operator Overloading#首先定义两个复数类，并使用&#43;=使这两个类相加。
complex c1 (5, 1);complex c2 (2);c2 &#43;= c1;c2 &#43;= c1 &#43;= c1; 我们的目标是实现一组合格的操作符重载。
inline complex&amp; complex::operator &#43;= (const complex&amp; r) {return __doapl(this, r);}inline complex&amp; __doapl(complex* ths, const complex&amp; r) {ths-&gt;re &#43;= r.re;ths-&gt;im &#43;= r.im;return *ths;} inline#inline牵扯到编译器认为此段代码何时应该展开的实现细节，很难在此论述它的含义，有兴趣可以去看gcc的实现
__doapl的设计考量#这种设计目的是为了将goal和functional process分离，比如我要做A，A包括了2个很common的动作X和Y，那么X、Y都应当单独封装
do A() { X; Y; }do X() {}do Y() {} 类内和类外#众所周知，操作符重载还有另一种常见的形式">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="对操作符重载的学习" />
<meta property="og:description" content="A Review at Operator Overloading#首先定义两个复数类，并使用&#43;=使这两个类相加。
complex c1 (5, 1);complex c2 (2);c2 &#43;= c1;c2 &#43;= c1 &#43;= c1; 我们的目标是实现一组合格的操作符重载。
inline complex&amp; complex::operator &#43;= (const complex&amp; r) {return __doapl(this, r);}inline complex&amp; __doapl(complex* ths, const complex&amp; r) {ths-&gt;re &#43;= r.re;ths-&gt;im &#43;= r.im;return *ths;} inline#inline牵扯到编译器认为此段代码何时应该展开的实现细节，很难在此论述它的含义，有兴趣可以去看gcc的实现
__doapl的设计考量#这种设计目的是为了将goal和functional process分离，比如我要做A，A包括了2个很common的动作X和Y，那么X、Y都应当单独封装
do A() { X; Y; }do X() {}do Y() {} 类内和类外#众所周知，操作符重载还有另一种常见的形式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pipvkings.github.io/docs/example/table-of-contents/operator-overloading-zh/" /><meta property="article:section" content="docs" />


<title>对操作符重载的学习 | 首頁介紹</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.a1bc3f1d714233dbb3581a7510c0be58c1aadad42dcdfaaecec1aaa38023c9e2.css" integrity="sha256-obw/HXFCM9uzWBp1EMC&#43;WMGq2tQtzfquzsGqo4AjyeI=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.f0c6fac7200a71399e3465a133f38930434c055e2ca71404d6ad0a7d22d66c03.js" integrity="sha256-8Mb6xyAKcTmeNGWhM/OJMENMBV4spxQE1q0KfSLWbAM=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>首頁介紹</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>Contents Post</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/after-school/" class="">After School</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/after-school/meaning-of-work/" class="">上班的意義</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/after-school/2023scc/" class="">个人数据的标准合同条款</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/" class="">At School</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/operator-overloading/" class="">A Review at Operator Overloading</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/cppio/" class="">C&#43;&#43; IO的简单复习</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/cpp_thread/" class="">C&#43;&#43;的线程同步</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/lseek/" class="">lseek和空洞文件</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/shared_p/" class="">shared_ptr的用例</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/uniq_p/" class="">unique_ptr的用例</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/operator-overloading-zh/" class="active">对操作符重载的学习</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/os-review/" class="">操作系统中的进程和锁</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/smart_pointer/" class="">智能指针</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/type-casting-zh/" class="">浅谈C&#43;&#43;中的类型转换</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/sliding_windows_prot/" class="">滑动窗口</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/rawp/" class="">裸指针和其修饰字</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>对操作符重载的学习</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown"><h2 id="a-review-at-operator-overloading">
  A Review at Operator Overloading
  <a class="anchor" href="#a-review-at-operator-overloading">#</a>
</h2>
<p>首先定义两个复数类，并使用<code>+=</code>使这两个类相加。</p>
<pre tabindex="0"><code>complex c1 (5, 1);
complex c2 (2);
c2 += c1;
c2 += c1 += c1;
</code></pre><p>我们的目标是实现一组合格的操作符重载。</p>
<pre tabindex="0"><code>inline complex&amp; complex::operator += (const complex&amp; r) {
  return __doapl(this, r);
}
inline complex&amp; __doapl(complex* ths, const complex&amp; r) {
  ths-&gt;re += r.re;
  ths-&gt;im += r.im;
  return *ths;
}
</code></pre><h2 id="inline">
  <code>inline</code>
  <a class="anchor" href="#inline">#</a>
</h2>
<p><code>inline</code>牵扯到编译器认为此段代码何时应该展开的实现细节，很难在此论述它的含义，有兴趣可以去看gcc的实现</p>
<h2 id="__doapl的设计考量">
  <code>__doapl</code>的设计考量
  <a class="anchor" href="#__doapl%e7%9a%84%e8%ae%be%e8%ae%a1%e8%80%83%e9%87%8f">#</a>
</h2>
<p>这种设计目的是为了将goal和functional process分离，比如我要做A，A包括了2个很common的动作X和Y，那么X、Y都应当单独封装</p>
<pre tabindex="0"><code>do A() { X; Y; }
do X() {}
do Y() {}
</code></pre><h2 id="类内和类外">
  类内和类外
  <a class="anchor" href="#%e7%b1%bb%e5%86%85%e5%92%8c%e7%b1%bb%e5%a4%96">#</a>
</h2>
<p>众所周知，操作符重载还有另一种常见的形式</p>
<pre tabindex="0"><code>inline complex operator+(const complex&amp; x, const complex&amp; y) {
  return complex(real(x) + real(y), image(x) + image(y));
}
complex c1, c2, c3;
c2 = c1 + c2;
</code></pre><p>通过发现它和上部分的区别，产生问题：什么时候参数里有两个值，什么时候有一个值？<code>c1 = c2 + c3 + c4</code>和<code>c1 += c2 += c3</code>的处理逻辑会因为参数而改变么？</p>
<blockquote>
<p>这涉及<code>this</code>指针省略的问题，对于<code>inline complex&amp; complex::operator += (const complex&amp; r)</code>函数，编译器会将它认为是<code>inline complex&amp; complex::operator += (this, const complex &amp; r)</code>，因为它是类的成员函数，所以多了一个<code>this</code>，代表这个类的实例本身，所以<code>c2 += c1</code>，本质上还是两个参数，为什么只写一个参数是因为剩下的那个（隐藏的）参数代表自身。</p>
</blockquote>
<h2 id="为什么操作符重载可以连续累加">
  为什么操作符重载可以连续累加？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%93%8d%e4%bd%9c%e7%ac%a6%e9%87%8d%e8%bd%bd%e5%8f%af%e4%bb%a5%e8%bf%9e%e7%bb%ad%e7%b4%af%e5%8a%a0">#</a>
</h2>
<p>针对类内：为什么可以<code>c1+=c2+=c1+=cn......</code>，因为它的实现是返回一个<code>complex&amp;</code>，假设不返回<code>complex&amp;</code>而返回一个void，结果会导致：<code>c1+=c2</code>没有问题，但是<code>c1+=c2+=c3</code>会出现不能将空转换为<code>complex&amp;</code>的错误。所以类内重载要用<code>&amp;</code>，但是直接return by value也是可以的，用<code>&amp;</code>只是因为性能考量。</p>
<p>对于类外：基本不可以return by ref，因为生命周期会消失。</p>
<pre tabindex="0"><code>// 合法，为什么？不知道
inline complex&amp; operator+ (const complex&amp; x) {
   return x;
}
cout &lt;&lt; (+x) &lt;&lt; endl;
</code></pre><pre tabindex="0"><code>// 不合法，因为必须返回本地对象，不能返回complex&amp;
inline complex&amp; operator- (const complex&amp; x) {
  return complex(-real(x), -image(x));
}
// 同不合法
inline complex&amp; operator+(const complex&amp; x, const complex&amp; y)
</code></pre><h2 id="为什么重载需要在类外">
  为什么重载<code>&lt;&lt;</code>需要在类外
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%87%8d%e8%bd%bd%e9%9c%80%e8%a6%81%e5%9c%a8%e7%b1%bb%e5%a4%96">#</a>
</h2>
<pre tabindex="0"><code>inline complex conj(const complex &amp;x ) {
  return complex(real(x), -image(x));
}
cout &lt;&lt; conj(c1) &lt;&lt; endl;
cout &lt;&lt; conj(c1) &lt;&lt; conj(c2) &lt;&lt; endl;
</code></pre><pre tabindex="0"><code>#include &lt;iostream&gt;
ostream&amp; operator &lt;&lt; (ostream&amp; os, complex&amp; c1) {
  return os &lt;&lt; &#34;image&#34; &lt;&lt; c1.image &lt;&lt;  &#34;real&#34; &lt;&lt; c1.real;
}
</code></pre><p>这个无法写成类函数，因为<code>cout</code>是一个<code>ostream</code>对象，标准库写好的，我们只能写成global，然后，按照<code>ostream &lt;&lt; complex</code>的结构，我们将第一个参数定义为<code>ostream&amp; os</code>, <code>&amp;</code>为了效率</p>
<ul>
<li>不能加<code>const</code>，因为加了<code>const</code>我们就没有办法写入这个<code>ostream</code>。</li>
<li>对于连续输出<code>&lt;&lt;</code>，本质是一个执行顺序的问题，从左到右，返回<code>ostream&amp;</code>，（不存在<code>ostream&amp;</code>对象在函数内销毁的问题，所以没必要输出<code>ostream</code>值类型）</li>
</ul>
<blockquote>
<p>C++每一个部分都很烧脑，上述问题这算是一个难点之一。</p>
</blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  
</body>
</html>












