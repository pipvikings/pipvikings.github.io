[{"id":0,"href":"/docs/example/table-of-contents/operator-overloading/","title":"A Review at Operator Overloading","section":"At School","content":"\rA Review at Operator Overloading\r#\rAhead all of those we define a complex class\ncomplex c1 (5, 1);\rcomplex c2 (2);\rc2 += c1;\rc2 += c1 += c1; Our aims are obvious: to define a bunch of valid operator overloadings\ninline complex\u0026amp; complex::operator += (const complex\u0026amp; r) {\rreturn __doapl(this, r);\r}\rinline complex\u0026amp; __doapl(complex* ths, const complex\u0026amp; r) {\rths-\u0026gt;re += r.re;\rths-\u0026gt;im += r.im;\rreturn *ths;\r} Those 2 snippets of code comes from standard lib, seemingly simple but in fact have a complex design perspective\n3 direct questions are raised:\nwhy inline? why making a separate __doapl? what is the exact behind the scene when we overload a \u0026ldquo;plus equal\u0026rdquo;? The reason when ppl make an inline is just for boosting speed, nothing special about it and a __doapl wrapping shows that the actual functional block should separate from wrapped block. While for the 3rd question, it is quite complex.\nto be continued im poor in english\r#\r"},{"id":1,"href":"/docs/example/table-of-contents/cppio/","title":"C++ IO的简单复习","section":"At School","content":"\r前言\r#\r从第一行hello world开始，很多人就对C++ IO的使用非常模糊，接下来简单讨论一下C++的IO，C语言的printf()和scanf()无法直接打印一个用户自定义类，因为它并无运算符重载，而C++可以通过重载iostream来达到这个效果，我们可以直观的看出printf()和和scanf()是基于funtion的（只是函数），而cin和cout是基于对象的（因为cin和cout分别是ostream和istream的对象）。\n我们最常用的就是iostream，涵盖了cin，cout，cerr，clog四个对象和wcin，wcout，wcerr，wclog四个宽字符的用法，深究它到底引用了哪些头文件过于错综复杂，并无实战意义。 cout和\u0026lt;\u0026lt;为什么可以连续操作符重载\r#\rcout是ostream的对象，指向显示器屏幕，是iostream中的全局对象，而连续使用cout \u0026lt;\u0026lt;的本质是什么呢？比如：\ncout \u0026lt;\u0026lt; \u0026#34;far\u0026#34; \u0026lt;\u0026lt; \u0026#34;boo\u0026#34; \u0026lt;\u0026lt; endl; 可以看作是执行了\nostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;temp,int source);\rostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;temp,char *ps);\r.... 因为cout本身就是ostream的对象，而cout \u0026lt;\u0026lt; \u0026quot;far\u0026quot;的返回本身又是一个ostream\u0026amp;，所以可以连续使用\u0026lt;\u0026lt;。\nfstream\r#\r#include \u0026lt;fstream\u0026gt; using namespace std; int main() { ofstream myfile(\u0026#34;my_path\u0026#34;,ios::out|ios::trunc,0); myfile\u0026lt;\u0026lt;\u0026#34;far\u0026#34;; myfile.close() system(\u0026#34;pause\u0026#34;); } 等同于\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; int main() { ofstream myfile; myfile.open(\u0026#34;my_path\u0026#34;,ios::out|ios::app,0); if(!myfile)\r{ cout\u0026lt;\u0026lt;\u0026#34;failed open file\u0026#34;; system(\u0026#34;pause\u0026#34;); exit(1); } myfile\u0026lt;\u0026lt;\u0026#34;far\u0026#34;;\rmyfile.close(); } 以下是用fstream拷贝文件的例子\n// Copy a file\r#include \u0026lt;fstream\u0026gt; // std::ifstream, std::ofstream\rint main () {\rstd::ifstream infile (\u0026#34;test.txt\u0026#34;,std::ifstream::binary);\rstd::ofstream outfile (\u0026#34;new.txt\u0026#34;,std::ofstream::binary);\r// get size of file\rinfile.seekg (0,infile.end);\rlong size = infile.tellg();\rinfile.seekg (0);\r// allocate memory for file content\rchar* buffer = new char[size];\r// read content of infile\rinfile.read (buffer,size);\r// write to outfile\routfile.write (buffer,size);\r// release dynamically-allocated memory\rdelete[] buffer;\routfile.close();\rinfile.close();\rreturn 0;\r} 值得注意的是ifstream的文档里面只对应read函数，同样ofstream的文档里只对应write 对比一下其他易混淆的read和write\r#\r需要注意到此read和彼read是两个read，write同样，上段提到的是包含在C++标准库里的，而包含在头文件\u0026lt;unistd.h\u0026gt;里的读写并不是C++标准库的而是UNIX系统调用\n#include \u0026lt;unistd.h\u0026gt;\rssize_t read(int fd, void *buf, size_t count); 上述函数从fd指向的文件中读取数据到buf，count是要求读到的字节数。fd为相应的文件描述符；buf为用户给定的数据缓冲区，该缓冲不是固定大小的，由count值决定其大小（用户给定字节数）。如read(fd, \u0026quot;hello\u0026quot;, 5);, 此时的void *buf被强制转换成char *类型，count为请求读取的字节数（即buf的大小）。该函数的返回值为-1时，表示读取数据失败；返回值大于0时，表示读出的字节数；返回值等于0时，表示已经读完了，因此没有数据可读。（注：ssize_t为有符号整型，size_t为无符号整型） write函数相反，向打开的设备或文件中写入数据，即将数据从用户空间（IO缓冲）送到内核-\u0026gt;刷到外设上。\n#include \u0026lt;unistd.h\u0026gt;\rssize_t write(int fd, const void *buf, size_t count); 从buf中写数据到fd所指向的文件中，count是相求写入的字节数，返回值通常与参数nbytes相同，否则表示出错。\n"},{"id":2,"href":"/docs/example/table-of-contents/cpp_thread/","title":"C++的线程同步","section":"At School","content":"\r进程和线程\r#\r（假定使用C++或C面向服务器编程）\n并行（Concurrent）和并发（parallel）的区别是：单核CPU内的Multi Thread叫做Concurrent，而多核时代的Multi Thread叫做Parallel，即：真正存在在一个时刻多个Thread在执行而不是一个时间时刻多个Thread在执行。\n同时应运而生的有超线程技术，例如：四核八线程CPU代表了单核会有2个Thread在运行。面试考的有多线程并发和多进程并发，多进程并发涉及进程之间的七种沟通方式：pipe，semafore，fifo，message queue，shared memory，socket，signal。\n不论哪一种都涉及大量底层API，每一个功能包括的头文件全都不一样，在这里把这七种全介绍完，相当于用中文复述一遍Advanced Unix Programming Environment半本书的内容，而且目测这些内容的考题已经逼近社招的难度，所以在这里没必要赘述。\n相比我们已经粗略了解多进程编程相比于多线程编程的优势和劣势，那么接下来简单介绍一下多线程的背景。经过查阅各种博客，发现C++11标准库包括了多线程的部分、包括了锁的部分，也就是说C++11之前的程序全部都是用Linux下的pthread、Linux内置的lock（排除三方库），那么对于C++的多进程支持呢？很巧，只有Boost库支持，那么我们如果不用Boost库，就只能用纯C混搭C++来支持多进程。以上，就是对于这个话题的粗略回顾。\n以下C++的例子来自于cpp reference，通过这些例子，我们可以大概了解S锁和X锁的原型\nstd::threading\r#\rClass to represent individual threads of execution. std::thread类表示了执行中的单独线程\nA thread of execution is a sequence of instructions that can be executed concurrently with other such sequences in multithreading environments, while sharing a same address space. 执行中的线程是一系列指令的组合，这些指令可以在多线程环境下与其他指令并发执行，并共享同一寻址空间。\nAn initialized thread object represents an active thread of execution; Such a thread object is joinable, and has a unique thread id. 一个初始化的`std::thread对象代表了一个激活了的对象，此对象被声明为joinable的，并且获得一个线程ID。\nA default-constructed (non-initialized) thread object is not joinable, and its thread id is common for all non-joinable threads. 默认构造的线程对象并不是initialized的，所以不是joinable的，它的线程ID和所有non-joinable的thread一样。\nA joinable thread becomes not joinable if moved from, or if either join or detach are called on them. 一个joinable的thread如果使用了move或者join和detach，就会变成non-joinable。\n// thread example\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\rvoid foo() {\r// do stuff...\r}\rvoid bar(int x)\r{\r// do stuff...\r}\rint main() {\rstd::thread first (foo); // spawn new thread that calls foo()\rstd::cout \u0026lt;\u0026lt; \u0026#34;main, foo and bar now execute concurrently...\\n\u0026#34;;\r// synchronize threads:\rfirst.join(); // pauses until first finishes\rsecond.join(); // pauses until second finishes\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo and bar completed.\\n\u0026#34;;\rreturn 0;\r} get_id\r#\r假设当前thread是joinable的，get_id()函数返回当前线程id，否则返回默认thread::id\n// thread::get_id / this_thread::get_id\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread, std::thread::id, std::this_thread::get_id\r#include \u0026lt;chrono\u0026gt; // std::chrono::seconds\rstd::thread::id main_thread_id = std::this_thread::get_id();\rvoid is_main_thread() {\rif ( main_thread_id == std::this_thread::get_id() )\rstd::cout \u0026lt;\u0026lt; \u0026#34;This is the main thread.\\n\u0026#34;;\relse\rstd::cout \u0026lt;\u0026lt; \u0026#34;This is not the main thread.\\n\u0026#34;;\r}\rint main() {\ris_main_thread();\rstd::thread th (is_main_thread);\rth.join();\r} join\r#\rjoin()的返回类型是void，当线程结束时返回，否则block waiting，在执行join()之后，该thread变为none joinable thread\n// example for thread::join\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread, std::this_thread::sleep_for\r#include \u0026lt;chrono\u0026gt; // std::chrono::seconds\rvoid pause_thread(int n) {\rstd::this_thread::sleep_for (std::chrono::seconds(n));\rstd::cout \u0026lt;\u0026lt; \u0026#34;pause of \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; seconds ended\\n\u0026#34;;\r}\rint main() {\rstd::cout \u0026lt;\u0026lt; \u0026#34;Spawning 3 threads...\\n\u0026#34;;\rstd::thread t1 (pause_thread,1);\rstd::thread t2 (pause_thread,2);\rstd::thread t3 (pause_thread,3);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Done spawning threads. Now waiting for them to join:\\n\u0026#34;;\rt1.join();\rt2.join();\rt3.join();\rstd::cout \u0026lt;\u0026lt; \u0026#34;All threads joined!\\n\u0026#34;;\rreturn 0;\r} joinable\r#\r一个线程有三种情况是none joinable的，第一种是当它被default construct的时候，第二种情况是它被detach或者join了之后，第三种情况是用了move语法给了其他线程。\n// example for thread::joinable\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\rvoid mythread() {\r// do stuff...\r}\rint main() {\rstd::thread foo;\rstd::thread bar(mythread);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Joinable after construction:\\n\u0026#34; \u0026lt;\u0026lt; std::boolalpha;\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo.joinable() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar.joinable() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rif (foo.joinable()) foo.join();\rif (bar.joinable()) bar.join();\rstd::cout \u0026lt;\u0026lt; \u0026#34;Joinable after joining:\\n\u0026#34; \u0026lt;\u0026lt; std::boolalpha;\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo.joinable() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar.joinable() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} operator=\r#\rthread对象不能被copy，假设左值是none joinable的，那么右值就会给左值，然后右值变成\u0026quot;as if default contructed\u0026quot;的样子。假设左值是joinable的，就会terminate。\n// example for thread::operator=\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread, std::this_thread::sleep_for\r#include \u0026lt;chrono\u0026gt; // std::chrono::seconds\rvoid pause_thread(int n) {\rstd::this_thread::sleep_for (std::chrono::seconds(n));\rstd::cout \u0026lt;\u0026lt; \u0026#34;pause of \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; seconds ended\\n\u0026#34;;\r}\rint main() {\rstd::thread threads[5]; // default-constructed threads\rstd::cout \u0026lt;\u0026lt; \u0026#34;Spawning 5 threads...\\n\u0026#34;;\rfor (int i=0; i\u0026lt;5; ++i)\rthreads[i] = std::thread(pause_thread,i+1); // move-assign threads\rstd::cout \u0026lt;\u0026lt; \u0026#34;Done spawning threads. Now waiting for them to join:\\n\u0026#34;;\rfor (int i=0; i\u0026lt;5; ++i)\rthreads[i].join();\rstd::cout \u0026lt;\u0026lt; \u0026#34;All threads joined!\\n\u0026#34;;\rreturn 0;\r} swap\r#\r交换线程id，stack overflow上有讨论这个到底是不是只交换id，有一个回答是说不要把它当作交换id，而是交换线程本身。（待考究）\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;thread\u0026gt;\r#include \u0026lt;chrono\u0026gt;\rvoid foo()\r{\rstd::this_thread::sleep_for(std::chrono::seconds(1));\r}\rvoid bar()\r{\rstd::this_thread::sleep_for(std::chrono::seconds(1));\r}\rint main()\r{\rstd::thread t1(foo);\rstd::thread t2(bar);\rstd::cout \u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\r\u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::swap(t1, t2);\rstd::cout \u0026lt;\u0026lt; \u0026#34;after std::swap(t1, t2):\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\r\u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\r\u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rt1.swap(t2);\rstd::cout \u0026lt;\u0026lt; \u0026#34;after t1.swap(t2):\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\r\u0026lt;\u0026lt; \u0026#34;thread 1 id: \u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\r\u0026lt;\u0026lt; \u0026#34;thread 2 id: \u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rt1.join();\rt2.join();\r} detach\r#\r线程在detach之后就会none joinable，独立运行，不block waiting，一直到结束。\n#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread, std::this_thread::sleep_for\r#include \u0026lt;chrono\u0026gt; // std::chrono::seconds\rvoid pause_thread(int n) {\rstd::this_thread::sleep_for (std::chrono::seconds(n));\rstd::cout \u0026lt;\u0026lt; \u0026#34;pause of \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; seconds ended\\n\u0026#34;;\r}\rint main() {\rstd::cout \u0026lt;\u0026lt; \u0026#34;Spawning and detaching 3 threads...\\n\u0026#34;;\rstd::thread (pause_thread,1).detach();\rstd::thread (pause_thread,2).detach();\rstd::thread (pause_thread,3).detach();\rstd::cout \u0026lt;\u0026lt; \u0026#34;Done spawning threads.\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;(the main thread will now pause for 5 seconds)\\n\u0026#34;;\r// give the detached threads time to finish (but not guaranteed!):\rpause_thread(5);\rreturn 0;\r} std::mutex\r#\rmutex是一个lockable的对象，提供critical setion的exclusive access\n// mutex example\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\r#include \u0026lt;mutex\u0026gt; // std::mutex\rstd::mutex mtx; // mutex for critical section\rvoid print_block (int n, char c) {\r// critical section (exclusive access to std::cout signaled by locking mtx):\rmtx.lock();\rfor (int i=0; i\u0026lt;n; ++i) { std::cout \u0026lt;\u0026lt; c; }\rstd::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rmtx.unlock();\r}\rint main ()\r{\rstd::thread th1 (print_block,50,\u0026#39;*\u0026#39;);\rstd::thread th2 (print_block,50,\u0026#39;$\u0026#39;);\rth1.join();\rth2.join();\rreturn 0;\r} lock\r#\r调用的线程lock了mutex, 假设该mutex并没有被其他线程占用，那么这个调用线程就将其lock, 此线程拥有这个mutex，直到其调用unlock函数。否则block waiting或者deadlock，block waiting是该mutex已经被其他线程占用，死锁是因为该mutex被该线程的递归（重复）调用抢走了\u0026quot;key\u0026quot;，导致第一个线程无法unlock。（这个地方很难理解，需要用recursive lock来解死锁），返回类型void。\n// mutex::lock/unlock\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\r#include \u0026lt;mutex\u0026gt; // std::mutex\rstd::mutex mtx; // mutex for critical section\rvoid print_thread_id (int id) {\r// critical section (exclusive access to std::cout signaled by locking mtx):\rmtx.lock();\rstd::cout \u0026lt;\u0026lt; \u0026#34;thread #\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rmtx.unlock();\r}\rint main ()\r{\rstd::thread threads[10];\r// spawn 10 threads:\rfor (int i=0; i\u0026lt;10; ++i)\rthreads[i] = std::thread(print_thread_id,i+1);\rfor (auto\u0026amp; th : threads) th.join();\rreturn 0;\r} unlock\r#\r只需要注意一点，unlock一个没lock的mutex是undefined behavior\ntry lock\r#\rtry lock也是会递归死锁的。假设被mutex其他thread占用，那么return false，否则return true\n// mutex::try_lock example\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\r#include \u0026lt;mutex\u0026gt; // std::mutex\rvolatile int counter (0); // non-atomic counter\rstd::mutex mtx; // locks access to counter\rvoid attempt_10k_increases () {\rfor (int i=0; i\u0026lt;10000; ++i) {\rif (mtx.try_lock()) { // only increase if currently not locked:\r++counter;\rmtx.unlock();\r}\r}\r}\rint main ()\r{\rstd::thread threads[10];\r// spawn 10 threads:\rfor (int i=0; i\u0026lt;10; ++i)\rthreads[i] = std::thread(attempt_10k_increases);\rfor (auto\u0026amp; th : threads) th.join();\rstd::cout \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; \u0026#34; successful increases of the counter.\\n\u0026#34;;\rreturn 0;\r} 首先强调一下这并不是dead lock代码，因为并不存在一个线程内拿两个lock的情况，正确的输出结果大概是八万多，volatile的目的是声明一个被多线程共享的变量，被volatile声明的变量不会被从cache中读值（但这并不意味着它atomic了，它这里只起声明作用）\nlock guard\r#\r官网说了一句很矛盾的话：“Note though that the lock_guard object does not manage the lifetime of the mutex object in any way: the duration of the mutex object shall extend at least until the destruction of the lock_guard that locks it.” 但是我们很容易看出来它的unlock是和智能指针一样，由函数的生命周期决定的，结束调用析构函数的unlock。官网的意思很有可能是lock guard并不确保它一直托管lock，开发者需要自己确定在析构函数调用之前lock是有效的。\n// lock_guard example\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\r#include \u0026lt;mutex\u0026gt; // std::mutex, std::lock_guard\r#include \u0026lt;stdexcept\u0026gt; // std::logic_error\rstd::mutex mtx;\rvoid print_even (int x) {\rif (x%2==0) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; is even\\n\u0026#34;;\relse throw (std::logic_error(\u0026#34;not even\u0026#34;));\r}\rvoid print_thread_id (int id) {\rtry {\r// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:\rstd::lock_guard\u0026lt;std::mutex\u0026gt; lck (mtx);\rprint_even(id);\r}\rcatch (std::logic_error\u0026amp;) {\rstd::cout \u0026lt;\u0026lt; \u0026#34;[exception caught]\\n\u0026#34;;\r}\r}\rint main ()\r{\rstd::thread threads[10];\r// spawn 10 threads:\rfor (int i=0; i\u0026lt;10; ++i)\rthreads[i] = std::thread(print_thread_id,i+1);\rfor (auto\u0026amp; th : threads) th.join();\rreturn 0;\r} adopt_lock and defer_lock\r#\rstd::lock(m1, m2); // calling thread locks the mutex\rstd::lock_guard\u0026lt;std::mutex\u0026gt; lock1(m1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(m2, std::adopt_lock);\r// access shared data protected by the m1 and m2 std::unique_lock\u0026lt;std::mutex\u0026gt; lock1(m1, std::defer_lock); std::unique_lock\u0026lt;std::mutex\u0026gt; lock2(m2, std::defer_lock); std::lock(lock1, lock2);\r// access shared data protected by the m1 and m2 defer lock假定mutex无锁，adopt lock假定有锁。unique lock对于无defer lock和adopt lock或者try to lock的会报错，lock guard不会，所以lock guard有很大的机率block一个线程两次导致死锁。\nunique lock\r#\runique lock和lock guard差不多。\n// unique_lock constructor example\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;thread\u0026gt; // std::thread\r#include \u0026lt;mutex\u0026gt; // std::mutex, std::lock, std::unique_lock\r// std::adopt_lock, std::defer_lock\rstd::mutex foo,bar;\rvoid task_a () {\rstd::lock (foo,bar); // simultaneous lock (prevents deadlock)\rstd::unique_lock\u0026lt;std::mutex\u0026gt; lck1 (foo,std::adopt_lock);\rstd::unique_lock\u0026lt;std::mutex\u0026gt; lck2 (bar,std::adopt_lock);\rstd::cout \u0026lt;\u0026lt; \u0026#34;task a\\n\u0026#34;;\r// (unlocked automatically on destruction of lck1 and lck2)\r}\rvoid task_b () {\r// foo.lock(); bar.lock(); // replaced by:\rstd::unique_lock\u0026lt;std::mutex\u0026gt; lck1, lck2;\rlck1 = std::unique_lock\u0026lt;std::mutex\u0026gt;(bar,std::defer_lock);\rlck2 = std::unique_lock\u0026lt;std::mutex\u0026gt;(foo,std::defer_lock);\rstd::lock (lck1,lck2); // simultaneous lock (prevents deadlock)\rstd::cout \u0026lt;\u0026lt; \u0026#34;task b\\n\u0026#34;;\r// (unlocked automatically on destruction of lck1 and lck2)\r}\rint main ()\r{\rstd::thread th1 (task_a);\rstd::thread th2 (task_b);\rth1.join();\rth2.join();\rreturn 0;\r} shared lock\r#\rshared lock是cpp14的内容，如果你去cppreference上查是可以查到的，但是你并不能在cplusplus com上查到，因为这个网站只包括c++11的简单教程。\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;mutex\u0026gt;\r#include \u0026lt;string\u0026gt;\r#include \u0026lt;shared_mutex\u0026gt;\r#include \u0026lt;thread\u0026gt;\rstd::string file = \u0026#34;Original content.\u0026#34;; // Simulates a file\rstd::mutex output_mutex; // mutex that protects output operations.\rstd::shared_mutex file_mutex; // reader/writer mutex\rvoid read(int id)\r{\rstd::string content;\r{\rstd::shared_lock lock(file_mutex, std::defer_lock); // Do not lock it first.\rlock.lock(); // Lock it here.\rcontent = file;\r}\rstd::lock_guard lock(output_mutex);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Contents read by reader #\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; content \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\r}\rvoid write()\r{\r{\rstd::lock_guard file_lock(file_mutex);\rfile = \u0026#34;New content\u0026#34;;\r}\rstd::lock_guard output_lock(output_mutex);\rstd::cout \u0026lt;\u0026lt; \u0026#34;New content saved.\\n\u0026#34;;\r}\rint main()\r{\rstd::cout \u0026lt;\u0026lt; \u0026#34;Two readers reading from file.\\n\u0026#34;\r\u0026lt;\u0026lt; \u0026#34;A writer competes with them.\\n\u0026#34;;\rstd::thread reader1(read, 1);\rstd::thread reader2(read, 2);\rstd::thread writer(write);\rreader1.join();\rreader2.join();\rwriter.join();\rstd::cout \u0026lt;\u0026lt; \u0026#34;The first few operations to file are done.\\n\u0026#34;;\rreader1 = std::thread(read, 3);\rreader1.join();\r} 我们可以看到，这里的share lock是共享模式的，和操作系统教材里说的读写锁意义一致，此外cout需要用互斥锁保证输出正常。\n差不多先到这，C++的多线程标准库有atomic future conditional variable thread mutex 等一坨库，这里只挑最简单的介绍\n由上我们可以窥见，数据库教材中所谓S锁与X锁在具体实操中的原型。\n"},{"id":3,"href":"/docs/example/table-of-contents/lseek/","title":"lseek和空洞文件","section":"At School","content":"\rfile discriptor的含义\r#\rlinux中有三种标准输入输出，分别是stdin，stdout，stderr，对应的数字是0、1、2。stdin是标准输入，默认从键盘读取信息；stdout是标准输出，默认将输出结果输出至终端；stderr是标准错误，默认将输出结果输出至终端。最常用的fd是0，1，2，这并不代表fd只能包含这三个数字，文件类型远不止标准输入输出这三个，还有管道、socket、目录等，可以通过修改配置文件解放fd数量的上限。\n空洞文件的含义\r#\r空洞文件是UNIX操作系统的一个概念，是文件指针的偏移量可以大过这个文件本身，于是乎产生了空洞，目的是为了让多线程同时写这个文件（因为文件中可以制造很多空洞）。注意：不一定制造空洞文件等于预先制造大量的空间，因为这取决于上层文件系统如何实现。\n\u0026lt;unistd.h\u0026gt;和lseek\r#\runistd.h是C和C++提供对POSIX操作系统API访问功能头文件的名称，是Unix Standard的缩写。该头文件由POSIX标准（单一UNIX规范的基础）提出，所有遵循该标准的操作系统和编译器均应提供该头文件（Unix的所有官方版本）。对于类 Unix系统，unistd.h中所定义的接口通常都是大量针对系统调用的封装（wrapper functions），如fork、pipe以及各种IO原语（read、write、close等等）。类似于Cygwin和MinGW的Unix兼容层也提供相应版本的unistd.h 综上浅显的分析一下：\nWindows 是没有lseek的，MacOS和Linux有lseek lseek也不是C或者C++标准库的，属于系统调用范畴 lseek需要两个头文件：第一个是unistd.h，第二个是sys/types.h，sys/types.h描述了不同的类型，也是POSIX的东西\ncurrent file offset\r#\r所有打开的文件都有一个当前文件偏移量（current file offset），简称为cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数，读写操作通常开始于cfo，并且使cfo增大，增量为读写的字节数。文件被打开时，cfo 会被初始化为0，除非使用了O_APPEND参数\nlseek\r#\r函数原型为off_t lseek(int filedis, off_t offset, int whence)，成功返回偏移量，失败返回-1（对socket和pipe也返回-1），off_t类型用于指示文件的偏移量，通常是是long类型，其默认为一个32位的整数，在gcc编译中会被编译为long int类型，在64位的Linux系统中则会被编译为long long int，一个64位的整数，其定义在unistd.h头文件中可以查看。 注意：应该判断lseek是否返回-1来判断对错而不是判断是否\u0026lt;0，因为cfo也有可能是负偏移。\n如果whence是SEEK_SET，文件偏移量将被设置为offset。 如果whence是SEEK_CUR，文件偏移量将被设置为cfo加上offset，offset可以为正也可以为负。 如果whence是SEEK_END，文件偏移量将被设置为文件长度加上offset，offset可以为正也可以为负。 c++ alternative solution\r#\r// read a file into memory\r#include \u0026lt;iostream\u0026gt; // std::cout\r#include \u0026lt;fstream\u0026gt; // std::ifstream\rint main () {\rstd::ifstream is (\u0026#34;test.txt\u0026#34;, std::ifstream::binary);\rif (is) {\r// get length of file:\ris.seekg (0, is.end);\rint length = is.tellg();\ris.seekg (0, is.beg);\r// allocate memory:\rchar * buffer = new char [length];\r// read data as a block:\ris.read (buffer,length);\ris.close();\r// print content:\rstd::cout.write (buffer,length);\rdelete[] buffer;\r}\rreturn 0;\r} seekg有两个参数，第一个参数是offset，第二个参数是“它以何种形式偏移”\nios::beg：表示输入流的开始位置 ios::cur：表示输入流的当前位置 ios::end：表示输入流的结束位置 istream\u0026amp; seekg (streampos pos);\ristream\u0026amp; seekg (streamoff off, ios_base::seekdir way); 关于streampos和streamoff是否完全等于unsigned long long int，stackoverflow上有深刻的讨论，可自行了解。\nc++的seek与c的异同\r#\r和C的文件操作方式不同的是，C++ IO系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以C++的文件定位分为读位置和写位置的定位，对应的成员函数是seekg()和seekp()，seekg()是设置读位置，seekp是设置写位置，tellp()对应的是tellg()。\nistream \u0026amp;seekg(streamoff offset, seek_dir origin);\rostream \u0026amp;seekp(streamoff offset, seek_dir origin); "},{"id":4,"href":"/docs/example/table-of-contents/shared_p/","title":"shared_ptr的用例","section":"At School","content":"\rstd::make_shared\r#\rstd::pair的first和second是第一个成员和第二个成员，第一个first和第二个second可以不一样\n// make_pair example\r#include \u0026lt;utility\u0026gt; // std::pair\r#include \u0026lt;iostream\u0026gt; // std::cout\rint main () {\rstd::pair \u0026lt;int,int\u0026gt; foo;\rstd::pair \u0026lt;int,int\u0026gt; bar;\rfoo = std::make_pair (10,20);\rbar = std::make_pair (10.5,\u0026#39;A\u0026#39;); // ok: implicit conversion from pair\u0026lt;double,char\u0026gt;\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; foo.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar.first \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; bar.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} // pair::operator= example\r#include \u0026lt;utility\u0026gt; // std::pair, std::make_pair\r#include \u0026lt;string\u0026gt; // std::string\r#include \u0026lt;iostream\u0026gt; // std::cout\rint main () {\rstd::pair \u0026lt;std::string,int\u0026gt; planet, homeplanet;\rplanet = std::make_pair(\u0026#34;Earth\u0026#34;,6371);\rhomeplanet = planet;\rstd::cout \u0026lt;\u0026lt; \u0026#34;Home planet: \u0026#34; \u0026lt;\u0026lt; homeplanet.first \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;Planet size: \u0026#34; \u0026lt;\u0026lt; homeplanet.second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 我们发现里面有std::shared_ptr\u0026lt;int\u0026gt; foo = std::make_shared\u0026lt;int\u0026gt; (10); same as: std::shared_ptr\u0026lt;int\u0026gt; foo2 (new int(10)); 这个东西要注意有两种形式的构造\n// make_shared example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo = std::make_shared\u0026lt;int\u0026gt; (10);\r// same as:\rstd::shared_ptr\u0026lt;int\u0026gt; foo2 (new int(10));\rauto bar = std::make_shared\u0026lt;int\u0026gt; (20);\rauto baz = std::make_shared\u0026lt;std::pair\u0026lt;int,int\u0026gt;\u0026gt; (30,40);\rstd::cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*baz: \u0026#34; \u0026lt;\u0026lt; baz-\u0026gt;first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; baz-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} allocate_shared\r#\r文档里有说 This function uses alloc to allocate storage for the object. A similar function, make_shared uses ::new to allocate the storage instead. 这个是用alloc分配的\n// allocate_shared example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::allocator\u0026lt;int\u0026gt; alloc; // the default allocator for int\rstd::default_delete\u0026lt;int\u0026gt; del; // the default deleter for int\rstd::shared_ptr\u0026lt;int\u0026gt; foo = std::allocate_shared\u0026lt;int\u0026gt; (alloc,10);\rauto bar = std::allocate_shared\u0026lt;int\u0026gt; (alloc,20);\rauto baz = std::allocate_shared\u0026lt;std::pair\u0026lt;int,int\u0026gt;\u0026gt; (alloc,30,40);\rstd::cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*baz: \u0026#34; \u0026lt;\u0026lt; baz-\u0026gt;first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; baz-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} std::static_pointer_cast\r#\r// static_pointer_cast example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rstruct A {\rstatic const char* static_type;\rconst char* dynamic_type;\rA() { dynamic_type = static_type; }\r};\rstruct B: A {\rstatic const char* static_type;\rB() { dynamic_type = static_type; }\r};\rconst char* A::static_type = \u0026#34;class A\u0026#34;;\rconst char* B::static_type = \u0026#34;class B\u0026#34;;\rint main () {\rstd::shared_ptr\u0026lt;A\u0026gt; foo;\rstd::shared_ptr\u0026lt;B\u0026gt; bar;\rfoo = std::make_shared\u0026lt;A\u0026gt;();\r// cast of potentially incomplete object, but ok as a static cast:\rbar = std::static_pointer_cast\u0026lt;B\u0026gt;(foo);\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo\u0026#39;s static type: \u0026#34; \u0026lt;\u0026lt; foo-\u0026gt;static_type \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo\u0026#39;s dynamic type: \u0026#34; \u0026lt;\u0026lt; foo-\u0026gt;dynamic_type \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar\u0026#39;s static type: \u0026#34; \u0026lt;\u0026lt; bar-\u0026gt;static_type \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar\u0026#39;s dynamic type: \u0026#34; \u0026lt;\u0026lt; bar-\u0026gt;dynamic_type \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 输出:\nfoo\u0026#39;s static type: class A\rfoo\u0026#39;s dynamic type: class A\rbar\u0026#39;s static type: class B\rbar\u0026#39;s dynamic type: class A 首先，const char* a::static_type = 'class a', 静态区成员a::static_type是 'class a'， 然后，const char* b::static_type = 'class b'，静态区成员b::static_type是 'class b'， 执行 std::shared_ptr\u0026lt; A \u0026gt; foo; std::shared_ptr\u0026lt; B \u0026gt; bar，bar和foo这两个现在是null了 执行 foo = std::make_shared\u0026lt; A \u0026gt;() ，构造函数使得foo的：const char* dynamic_type 等于 'class a'， 执行 bar=std::static_pointer\u0026lt; B \u0026gt;(foo), static_cast使得：bar为foo的值，所以bar是foo了 所以foo的值是：一个a::static_type是class a，一个dynamic type是class a bar是foo，bar的dynamic type是foo的dynamic type，是a bar的static type没有变，因为bar的static type并不是foo的static type，即使bar变成了foo，也只是非静态区变了，静态区没变 dynamic_pointer_cast\r#\rconst cast\r#\r虽然cpp官网上对于普通指针的const cast讲解例子只写了如何去除一个const，但是它有明确的说一点\u0026quot;either to be set or to be removed\u0026quot;，所以我们可以猜出，去除 / 添加一个const在智能指针里也是合法的 // static_pointer_cast example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo;\rstd::shared_ptr\u0026lt;const int\u0026gt; bar;\rfoo = std::make_shared\u0026lt;int\u0026gt;(10);\rbar = std::const_pointer_cast\u0026lt;const int\u0026gt;(foo);\rstd::cout \u0026lt;\u0026lt; \u0026#34;*bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\r*foo = 20;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 这个例子里，是说如何把一个int* 变成 const int * , c++ 的const cast大部分情况下是可以按照你预期的结果正常工作的，但是也有些许例外，这取决于如何声明、编译器如何优化。上面的例子里，输出结果是10和20 get_deleter\r#\r// get_deleter example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rstruct D { // a verbose array deleter:\rvoid operator()(int* p) {\rstd::cout \u0026lt;\u0026lt; \u0026#34;[deleter called]\\n\u0026#34;;\rdelete[] p;\r}\r};\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo (new int[10],D());\rint * bar = new int[20];\r// use foo\u0026#39;s deleter to delete bar (which is unmanaged):\r(*std::get_deleter\u0026lt;D\u0026gt;(foo))(bar);\rreturn 0;\r// foo\u0026#39;s deleter called automatically\r} 首先这个例子初始化了一个有10单位长度智能指针，由于它声明的是int，然后第一个参数是一个int[]，所以普通的std deleter是不管用的，因为只删除首地址，所以要自定义删除器D\nstruct D {\rvoid operator()(int* p) {\rstd::cout \u0026lt;\u0026lt; \u0026#34;\u0026#34;;\rdelete[] p;\r}\r} 注意是谁delete[] p，这是手动构造删除器的目的 但是下面还有一个int * bar = new int [20]这个东西 然后我们用std::get_deleter\u0026lt; D \u0026gt; (foo) 可以删除foo，这个类型是一个删除器指针 于是，我们可以连续指针操作: (*std::get_deleter\u0026lt;D\u0026gt;(foo)) // 还是一个删除器 于是\n(*std::get_deleter\u0026lt;D\u0026gt;(foo))(bar); // 删除bar 网上有很多深刻的讨论关于为什么智能指针有两种获取deleter的方式，我觉得我是看不懂了，大概是unique的要设计成模版，为了保持低内存而不把deleter当作类内的一部分，shared并不太过care内存，所以两种获取方式也就可以理解了。 swap\r#\rswap是重载的函数 // shared_ptr swap specialization\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo (new int(10));\rstd::shared_ptr\u0026lt;int\u0026gt; bar (new int(20));\rswap(foo,bar);\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} operator \u0026laquo;\r#\r// shared_ptr i/o\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo (new int (10));\rstd::cout \u0026lt;\u0026lt; \u0026#34; foo: \u0026#34; \u0026lt;\u0026lt; foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 输出结果是\nfoo: 0x920d90\r*foo: 10 注：我还没有试过unique ptr是否有 \u0026lt;\u0026lt; 的 operator overloading ，反正文档上没有 relational operator\r#\r不写了 上述的所有东西统统都不是类函数\n下述例子来源 https://www.cnblogs.com/jiayayao/p/6128877.html\n#include \u0026#34;stdafx.h\u0026#34;\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;future\u0026gt;\r#include \u0026lt;thread\u0026gt;\rusing namespace std;\rclass Person\r{\rpublic:\rPerson(int v) {\rvalue = v;\rstd::cout \u0026lt;\u0026lt; \u0026#34;Cons\u0026#34; \u0026lt;\u0026lt;value\u0026lt;\u0026lt; std::endl;\r}\r~Person() {\rstd::cout \u0026lt;\u0026lt; \u0026#34;Des\u0026#34; \u0026lt;\u0026lt;value\u0026lt;\u0026lt; std::endl;\r}\rint value;\r};\rint main()\r{\rstd::shared_ptr\u0026lt;Person\u0026gt; p1(new Person(1));// Person(1)的引用计数为1\rstd::shared_ptr\u0026lt;Person\u0026gt; p2 = std::make_shared\u0026lt;Person\u0026gt;(2);\rp1.reset(new Person(3));// 首先生成新对象，然后引用计数减1，引用计数为0，故析构Person(1)\r// 最后将新对象的指针交给智能指针\rstd::shared_ptr\u0026lt;Person\u0026gt; p3 = p1;//现在p1和p3同时指向Person(3)，Person(3)的引用计数为2\rp1.reset();//Person(3)的引用计数为1\rp3.reset();//Person(3)的引用计数为0，析构Person(3)\rreturn 0;\r} 首先我们解释一下什么是引用计数，首先初始化一个shared ptr p1，然后其中的成员是new Person(1) 内存布局可以理解为，一个heap区域的person类其地址为（假设为hp1），然后一个shared ptr在stack区，叫做p1 然后同样的：heap区域的person类person(2)和其地址为hp2，然后一个shared ptr在stack区：p2 p1 reset一个new person(3), 这个的解释过程为：首先在heap区new一个person 3，其地址为hp3，然后，执行reset函数，因为reset的目的永远是释放一个count，所以count - 1变成0，然后析构person(1)，所以，hp1消失,然后hp3交给p1，count自增 然后复制一个shared ptr p3，值是p1，里面的内容也是一样的, 我们发现hp3既交给了p1也交给了p3，count为2 p1.reset, count\u0026ndash; p3.reset, count\u0026ndash; 所以我们可以发现，share ptr的share为什么是share? 它代表的是多个share指针共享一个堆资源\n疑问\n来源cpp prime的一句话：shared_ptr自动销毁所管理的对象 当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象，它是通过另一个特殊的成员函数-析构函数完成销毁工作的，类似于构造函数，每个类都有一个析构函数。析构函数控制对象销毁时做什么操作。析构函数一般用来释放对象所分配的资源。shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。 然后不仅仅是这一个博客上有说：不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁 int *p5 = new int;\rstd::shared_ptr\u0026lt;int\u0026gt; p6(p5);\rstd::shared_ptr\u0026lt;int\u0026gt; p7(p5);// logic error 上述代码很好理解，二次销毁 我的问题是，这篇文章的第一份代码不也是两个指针指向一个资源吗？为什么这个就没有错呢？\n答案是：第一份代码是两个智能指针有着一模一样的值，它是shared ptr（语义上），指向一个资源，它们在stack区域的值是一模一样的，=之间应该是有运算符重载的机制让count自增（代表了shared，所以count自增）\n但是第二个例子不对的地方在于，它并不是智能指针的赋值，它是让一个指针进入两个构造函数，所以count应该是无自增的机制的\n第一个例子由shared ptr自己的机制进行垃圾回收，根据count何时减到0\n另外，不要在函数实参中创建shared_ptr // 错\rfunction(shared_ptr\u0026lt;int\u0026gt;(new int), g()); 通过查阅文档我们发现unique ptr的默认删除器是支持释放数组对象的，如: std::unique_ptr\u0026lt;int[]\u0026gt; foo (new int[5]); 但是shared ptr 不支持[] ，所以我们要自定义deleter\n关于到底是int[]还是int，自定义（不自定义）deleter的问题，我直说了: 我看不懂，因为20，17，11三个版本的要求全不一样，感兴趣的参见这篇博客 https://www.cnblogs.com/apocelipes/p/10346928.html 到时候开发就现查文档\n另外，注意unique ptr可以转shared ptr，反过来不可，比如 #include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rusing namespace std;\rclass A{\rpublic:\rstring id;\rA(string id):id(id){cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#34;：构造函数\u0026#34;\u0026lt;\u0026lt;endl;}\r~A(){cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#34;：析构函数\u0026#34;\u0026lt;\u0026lt;endl;}\r};\rint main() {\runique_ptr\u0026lt;A\u0026gt; a(new A(\u0026#34;unique_ptr\u0026#34;));\rshared_ptr\u0026lt;A\u0026gt; b = move(a);\r// a = move(b); // 报错\r// a.reset(b.get()); // 运行错误\rcout\u0026lt;\u0026lt;a.get()\u0026lt;\u0026lt;endl;\rreturn 0;\r} 用get拿到智能指针的裸指针之后删掉它，会导致智能指针运行错误 不要用stack中的变量地址初始化一个smart pointer #include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rusing namespace std;\rclass A{\rpublic:\rstring id;\rA(string id):id(id){cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#34;：构造函数\u0026#34;\u0026lt;\u0026lt;endl;}\r~A(){cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#34;：析构函数\u0026#34;\u0026lt;\u0026lt;endl;}\r};\rA a(\u0026#34;全局变量\u0026#34;);\rint main() {\rA b(\u0026#34;局部变量\u0026#34;);\r// unique_ptr\u0026lt;A\u0026gt; pa(\u0026amp;a); // 运行错误\runique_ptr\u0026lt;A\u0026gt; pa(\u0026amp;b);\rreturn 0;\r} 谨慎使用智能指针的get与release方法\n通过unique_ptr.release()方法返回的裸指针，需要我们自己delete删除对象，因为调用release方法后，该unique_ptr不再拥有对象的所有权。 循环引用问题待更\n继续详细的过一遍shared ptr的文档，这些是成员函数\n构造函数\r#\r// shared_ptr constructor example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rstruct C {int* data;};\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; p1;\rstd::shared_ptr\u0026lt;int\u0026gt; p2 (nullptr);\rstd::shared_ptr\u0026lt;int\u0026gt; p3 (new int);\rstd::shared_ptr\u0026lt;int\u0026gt; p4 (new int, std::default_delete\u0026lt;int\u0026gt;());\rstd::shared_ptr\u0026lt;int\u0026gt; p5 (new int, [](int* p){delete p;}, std::allocator\u0026lt;int\u0026gt;());\rstd::shared_ptr\u0026lt;int\u0026gt; p6 (p5);\rstd::shared_ptr\u0026lt;int\u0026gt; p7 (std::move(p6));\rstd::shared_ptr\u0026lt;int\u0026gt; p8 (std::unique_ptr\u0026lt;int\u0026gt;(new int));\rstd::shared_ptr\u0026lt;C\u0026gt; obj (new C);\rstd::shared_ptr\u0026lt;int\u0026gt; p9 (obj, obj-\u0026gt;data);\rstd::cout \u0026lt;\u0026lt; \u0026#34;use_count:\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p1: \u0026#34; \u0026lt;\u0026lt; p1.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p3: \u0026#34; \u0026lt;\u0026lt; p3.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p4: \u0026#34; \u0026lt;\u0026lt; p4.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p5: \u0026#34; \u0026lt;\u0026lt; p5.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p6: \u0026#34; \u0026lt;\u0026lt; p6.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p7: \u0026#34; \u0026lt;\u0026lt; p7.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p8: \u0026#34; \u0026lt;\u0026lt; p8.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p9: \u0026#34; \u0026lt;\u0026lt; p9.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 输出结果：\nuse_count:\rp1: 0\rp2: 0\rp3: 1\rp4: 1\rp5: 2\rp6: 0\rp7: 2\rp8: 1\rp9: 2 p1的ref count是0，p2的ref count是0，p3是1，p4是1，p5是1，p6是2，p5是2，p6因为move了变成0，p7是2, p8是1, p9涉及Aliasing constructor，看不懂，是2 析构函数\r#\r// shared_ptr destructor example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rauto deleter = [](int*p){\rstd::cout \u0026lt;\u0026lt; \u0026#34;[deleter called]\\n\u0026#34;; delete p;\r};\rstd::shared_ptr\u0026lt;int\u0026gt; foo (new int,deleter);\rstd::cout \u0026lt;\u0026lt; \u0026#34;use_count: \u0026#34; \u0026lt;\u0026lt; foo.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0; // [deleter called]\r} 输出 use_count: 1\r[deleter_called] 我们可以看到，它自定义了一个deleter，这个deleter是个lambda表达式，然后\u0026lt;\u0026gt;里是没有那个unique ptr的deleter参数的 operator=\r#\r// shared_ptr::operator= example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo;\rstd::shared_ptr\u0026lt;int\u0026gt; bar (new int(10));\rfoo = bar; // copy\rbar = std::make_shared\u0026lt;int\u0026gt; (20); // move\rstd::unique_ptr\u0026lt;int\u0026gt; unique (new int(30));\rfoo = std::move(unique); // move from unique_ptr\rstd::cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 输出 *foo: 30\r*bar: 20 不解释了，没啥好解释的 swap\r#\r// shared_ptr::swap example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo (new int(10));\rstd::shared_ptr\u0026lt;int\u0026gt; bar (new int(20));\rfoo.swap(bar);\rstd::cout \u0026lt;\u0026lt; \u0026#34;*foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;*bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} output *foo: 20\r*bar: 10 没啥解释的 get()\r#\r// shared_ptr::get example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rint* p = new int (10);\rstd::shared_ptr\u0026lt;int\u0026gt; a (p);\rif (a.get()==p)\rstd::cout \u0026lt;\u0026lt; \u0026#34;a and p point to the same location\\n\u0026#34;;\r// three ways of accessing the same address:\rstd::cout \u0026lt;\u0026lt; *a.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;\rreturn 0;\r} output a and p point to the same location\r10\r10\r10 我们可以发现，不论是智能指针还是raw pointer，都是一个值，估计是智能指针对 * 做了overloading // shared_ptr::operator*\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo (new int);\rstd::shared_ptr\u0026lt;int\u0026gt; bar (new int (100));\r*foo = *bar * 2;\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} output foo: 200\rbar: 100 不解释了 operator -\u0026gt;\r#\r// shared_ptr::operator-\u0026gt;\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rstruct C { int a; int b; };\rint main () {\rstd::shared_ptr\u0026lt;C\u0026gt; foo;\rstd::shared_ptr\u0026lt;C\u0026gt; bar (new C);\rfoo = bar;\rfoo-\u0026gt;a = 10;\rbar-\u0026gt;b = 20;\rif (foo) std::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo-\u0026gt;a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; foo-\u0026gt;b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rif (bar) std::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar-\u0026gt;a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; bar-\u0026gt;b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} output foo: 10 20\rbar: 10 20 use_count()\r#\rReturns the number of shared_ptr objects that share ownership over the same pointer as this object (including it).\nIf this is an empty shared_ptr, the function returns zero.\nLibrary implementations are not required to keep a count of any particular set of owners, and thus it may not be efficient to call this function. To check specifically whether use_count is 1, you can use member unique instead, which may be faster. 让你用unique检测有么有至少一个引用\nunique()\r#\r这是个bool的返回值 // shared_ptr::unique\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo;\rstd::shared_ptr\u0026lt;int\u0026gt; bar (new int);\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo unique?\\n\u0026#34; \u0026lt;\u0026lt; std::boolalpha;\rstd::cout \u0026lt;\u0026lt; \u0026#34;1: \u0026#34; \u0026lt;\u0026lt; foo.unique() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // false (empty)\rfoo = bar;\rstd::cout \u0026lt;\u0026lt; \u0026#34;2: \u0026#34; \u0026lt;\u0026lt; foo.unique() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // false (shared with bar)\rbar = nullptr;\rstd::cout \u0026lt;\u0026lt; \u0026#34;3: \u0026#34; \u0026lt;\u0026lt; foo.unique() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // true\rreturn 0;\r} output foo unique?\r1: false\r2: false\r3: true operator bool\r#\r// example of shared_ptr::operator bool\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::shared_ptr\u0026lt;int\u0026gt; foo;\rstd::shared_ptr\u0026lt;int\u0026gt; bar (new int(34));\rif (foo) std::cout \u0026lt;\u0026lt; \u0026#34;foo points to \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\relse std::cout \u0026lt;\u0026lt; \u0026#34;foo is null\\n\u0026#34;;\rif (bar) std::cout \u0026lt;\u0026lt; \u0026#34;bar points to \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\relse std::cout \u0026lt;\u0026lt; \u0026#34;bar is null\\n\u0026#34;;\rreturn 0;\r} output foo is null\rbar points to 34 std::shared_ptr::owner_before\r#\r这个涉及aliase constructor，我不会，待更\n"},{"id":5,"href":"/docs/example/table-of-contents/uniq_p/","title":"unique_ptr的用例","section":"At School","content":"// unique_ptr constructor example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::default_delete\u0026lt;int\u0026gt; d;\rstd::unique_ptr\u0026lt;int\u0026gt; u1;\rstd::unique_ptr\u0026lt;int\u0026gt; u2 (nullptr);\rstd::unique_ptr\u0026lt;int\u0026gt; u3 (new int);\rstd::unique_ptr\u0026lt;int\u0026gt; u4 (new int, d);\rstd::unique_ptr\u0026lt;int\u0026gt; u5 (new int, std::default_delete\u0026lt;int\u0026gt;());\rstd::unique_ptr\u0026lt;int\u0026gt; u6 (std::move(u5));\rstd::unique_ptr\u0026lt;int\u0026gt; u7 (std::move(u6));\rstd::unique_ptr\u0026lt;int\u0026gt; u8 (std::auto_ptr\u0026lt;int\u0026gt;(new int));\rstd::cout \u0026lt;\u0026lt; \u0026#34;u1: \u0026#34; \u0026lt;\u0026lt; (u1?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u2: \u0026#34; \u0026lt;\u0026lt; (u2?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u3: \u0026#34; \u0026lt;\u0026lt; (u3?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u4: \u0026#34; \u0026lt;\u0026lt; (u4?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u5: \u0026#34; \u0026lt;\u0026lt; (u5?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u6: \u0026#34; \u0026lt;\u0026lt; (u6?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u7: \u0026#34; \u0026lt;\u0026lt; (u7?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;u8: \u0026#34; \u0026lt;\u0026lt; (u8?\u0026#34;not null\u0026#34;:\u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 首先第一个例子，我们发现它的输出是\nu1: null\ru2: null\ru3: not null\ru4: not null\ru5: null\ru6: null\ru7: not null\ru8: not null std::default_delete\r#\rstd::default_delete is the default destruction policy used by std::unique_ptr when no deleter is specified.\nThe non-specialized default_delete uses delete to deallocate memory for a single object.\nA partial specialization for array types that uses delete[] is also provided.\n原型是template\u0026lt; class T \u0026gt; struct default_delete和template\u0026lt; class T \u0026gt; struct default_delete\u0026lt;T[]\u0026gt;\n所以我们得知，要么用默认的default delete，要么不写空着，不写空着也是给你默认是default delete，要么自己定制deleter。\n析构函数\r#\r// unique_ptr destructor example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rauto deleter = [](int*p){\rdelete p;\rstd::cout \u0026lt;\u0026lt; \u0026#34;[deleter called]\\n\u0026#34;;\r};\rstd::unique_ptr\u0026lt;int,decltype(deleter)\u0026gt; foo (new int,deleter);\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo \u0026#34; \u0026lt;\u0026lt; (foo?\u0026#34;is not\u0026#34;:\u0026#34;is\u0026#34;) \u0026lt;\u0026lt; \u0026#34; empty\\n\u0026#34;;\rreturn 0; // [deleter called]\r} 此程序自定义了一个deleter给一个智能指针，\u0026lt;\u0026gt;的第一个参数是int，也就是int* 指针，第二个是一个decltype(deleter)，decltype的用法基本等同于auto，都是编译时确定这个东西的类型，区别是auto要用这个变量,decltype推完了就拉倒\n这个deleter是一个lambda class，参见此链接 这里面有contructor的详细声明。\noperator=\r#\r// unique_ptr::operator= example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; foo;\rstd::unique_ptr\u0026lt;int\u0026gt; bar;\rfoo = std::unique_ptr\u0026lt;int\u0026gt;(new int (101)); // rvalue\rbar = std::move(foo); // using std::move\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34;;\rif (foo) std::cout \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cout \u0026lt;\u0026lt; \u0026#34;empty\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34;;\rif (bar) std::cout \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cout \u0026lt;\u0026lt; \u0026#34;empty\\n\u0026#34;;\rreturn 0;\r} 虽然unique ptr的拷贝构造函数和operator=都被设计成了delete，但是它有move构造，所以传参数，赋值，返回都没问题\nauto w = std::make_unique\u0026lt;Widget\u0026gt;();\rauto w2 = w; // 编译错误 上面的就是错的，只能move，估计因为左边的不是null，此代码第一个输出empty，第二个输出101。\nget\r#\rget获取那个裸指针，release是放空一个smart pointer里的raw pointer让其变成null\n// unique_ptr::get vs unique_ptr::release\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\r// foo bar p\r// --- --- ---\rstd::unique_ptr\u0026lt;int\u0026gt; foo; // null\rstd::unique_ptr\u0026lt;int\u0026gt; bar; // null null\rint* p = nullptr; // null null null\rfoo = std::unique_ptr\u0026lt;int\u0026gt;(new int(10)); // (10) null null\rbar = std::move(foo); // null (10) null\rp = bar.get(); // null (10) (10)\r*p = 20; // null (20) (20)\rp = nullptr; // null (20) null\rfoo = std::unique_ptr\u0026lt;int\u0026gt;(new int(30)); // (30) (20) null\rp = foo.release(); // null (20) (30)\r*p = 40; // null (20) (40)\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34;;\rif (foo) std::cout \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cout \u0026lt;\u0026lt; \u0026#34;(null)\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34;;\rif (bar) std::cout \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cout \u0026lt;\u0026lt; \u0026#34;(null)\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;p: \u0026#34;;\rif (p) std::cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; else std::cout \u0026lt;\u0026lt; \u0026#34;(null)\\n\u0026#34;;\rstd::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rdelete p; // the program is now responsible of deleting the object pointed to by p\r// bar deletes its managed object automatically\rreturn 0;\r} get_deleter\r#\r// unique_ptr deleter with state\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rclass state_deleter { // a deleter class with state\rint count_;\rpublic:\rstate_deleter() : count_(0) {}\rtemplate \u0026lt;class T\u0026gt;\rvoid operator()(T* p) {\rstd::cout \u0026lt;\u0026lt; \u0026#34;[deleted #\u0026#34; \u0026lt;\u0026lt; ++count_ \u0026lt;\u0026lt; \u0026#34;]\\n\u0026#34;;\rdelete p;\r}\r};\rint main () { state_deleter del;\rstd::unique_ptr\u0026lt;int\u0026gt; p; // uses default deleter\r// alpha and beta use independent copies of the deleter:\rstd::unique_ptr\u0026lt;int,state_deleter\u0026gt; alpha (new int);\rstd::unique_ptr\u0026lt;int,state_deleter\u0026gt; beta (new int,alpha.get_deleter());\r// gamma and delta share the deleter \u0026#34;del\u0026#34; (deleter type is a reference!):\rstd::unique_ptr\u0026lt;int,state_deleter\u0026amp;\u0026gt; gamma (new int,del);\rstd::unique_ptr\u0026lt;int,state_deleter\u0026amp;\u0026gt; delta (new int,gamma.get_deleter());\rstd::cout \u0026lt;\u0026lt; \u0026#34;resetting alpha...\u0026#34;; alpha.reset(new int);\rstd::cout \u0026lt;\u0026lt; \u0026#34;resetting beta...\u0026#34;; beta.reset(new int);\rstd::cout \u0026lt;\u0026lt; \u0026#34;resetting gamma...\u0026#34;; gamma.reset(new int);\rstd::cout \u0026lt;\u0026lt; \u0026#34;resetting delta...\u0026#34;; delta.reset(new int);\rstd::cout \u0026lt;\u0026lt; \u0026#34;calling gamma/delta deleter...\u0026#34;;\rgamma.get_deleter()(new int);\ralpha.get_deleter() = state_deleter(); // a brand new deleter for alpha\r// additional deletions when unique_ptr objects reach out of scope\r// (in inverse order of declaration)\rreturn 0;\r} 这一段代码解释了如何自定义构造一个deleter class，这个deleter class有一个template void operator()(T* p)的运算符重载，它的用法在底下可以看见某指针.get_deleter()(new int)的格式，我们看出new int对应的是模版里的T* p，这个删除器重载()的意思就是删除一个T* p。\n然后这个复杂的例子解释的是我们可以传递一个deleter进入这个指针，也可以不传递一个deleter进入这个指针，假设你在\u0026lt;\u0026gt;声明了这个deleter，那么假设不传递参数，那就是此deleter的默认（一个新值，而不是引用），假设不在\u0026lt;\u0026gt;声明deleter，然后就只能传std::default_deleter，假设声明且传参，那就是完全的自定义。\n还有一点值得注意的是，可以在\u0026lt;\u0026gt;声明引用，那么（）里的就会当成ref。\noperator bool重载\r#\r将一个智能指针当成bool\n// example of unique_ptr::operator bool\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; foo;\rstd::unique_ptr\u0026lt;int\u0026gt; bar (new int(12));\rif (foo) std::cout \u0026lt;\u0026lt; \u0026#34;foo points to \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\relse std::cout \u0026lt;\u0026lt; \u0026#34;foo is empty\\n\u0026#34;;\rif (bar) std::cout \u0026lt;\u0026lt; \u0026#34;bar points to \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\relse std::cout \u0026lt;\u0026lt; \u0026#34;bar is empty\\n\u0026#34;;\rreturn 0;\r} release\r#\r// unique_ptr::release example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; auto_pointer (new int);\rint * manual_pointer;\r*auto_pointer=10;\rmanual_pointer = auto_pointer.release();\r// (auto_pointer is now empty)\rstd::cout \u0026lt;\u0026lt; \u0026#34;manual_pointer points to \u0026#34; \u0026lt;\u0026lt; *manual_pointer \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rdelete manual_pointer;\rreturn 0;\r} 这个例子输出的是10，我们可以看出，release的目的是 Releases ownership of its stored pointer, by returning its value and replacing it with a null pointer. This call does not destroy the managed object，也就是将裸指针设为null，但是它的返回值是裸指针设为null之前的值\nreset\r#\r// unique_ptr::reset example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; up; // empty\rup.reset (new int); // takes ownership of pointer\r*up=5;\rstd::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rup.reset (new int); // deletes managed object, acquires new pointer\r*up=10;\rstd::cout \u0026lt;\u0026lt; *up \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rup.reset(); // deletes managed object\rreturn 0;\r} 我们可以发现，reset()接受一个裸指针，并销毁原先的指针，把封装指针变成参数里的那个。\nswap\r#\r// unique_ptr swap specialization\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; foo (new int(10));\rstd::unique_ptr\u0026lt;int\u0026gt; bar (new int(20));\rswap(foo,bar);\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 这是非成员函数的swap，下面的是成员函数的swap\n// unique_ptr::swap example\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; foo (new int(10));\rstd::unique_ptr\u0026lt;int\u0026gt; bar (new int(20));\rfoo.swap(bar);\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} swap的目的是交换指针的所有权，foo.swap(bar)\noperator* operator-\u0026gt;\r#\r// unique_ptr::operator*\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int\u0026gt; foo (new int);\rstd::unique_ptr\u0026lt;int\u0026gt; bar (new int (100));\r*foo = *bar * 2;\rstd::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; *foo \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; *bar \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 运算符重载 * ，返回A reference to the object pointed.\n// unique_ptr::operator-\u0026gt;\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rstruct C { int a; int b; };\rint main () {\rstd::unique_ptr\u0026lt;C\u0026gt; foo (new C);\rstd::unique_ptr\u0026lt;C\u0026gt; bar;\rfoo-\u0026gt;a = 10;\rfoo-\u0026gt;b = 20;\rbar = std::move(foo);\rif (foo) std::cout \u0026lt;\u0026lt; \u0026#34;foo: \u0026#34; \u0026lt;\u0026lt; foo-\u0026gt;a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; foo-\u0026gt;b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rif (bar) std::cout \u0026lt;\u0026lt; \u0026#34;bar: \u0026#34; \u0026lt;\u0026lt; bar-\u0026gt;a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; bar-\u0026gt;b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} 运算符重载 -\u0026gt; , 返回A pointer to the object managed by the unique_ptr.\noperator[]\r#\r// unique_ptr::operator[]\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;memory\u0026gt;\rint main () {\rstd::unique_ptr\u0026lt;int[]\u0026gt; foo (new int[5]);\rfor (int i=0; i\u0026lt;5; ++i) foo[i] = i;\rfor (int i=0; i\u0026lt;5; ++i) std::cout \u0026lt;\u0026lt; foo[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;;\rstd::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\rreturn 0;\r} "},{"id":6,"href":"/docs/example/table-of-contents/operator-overloading-zh/","title":"对操作符重载的学习","section":"At School","content":"\rA Review at Operator Overloading\r#\r首先定义两个复数类，并使用+=使这两个类相加。\ncomplex c1 (5, 1);\rcomplex c2 (2);\rc2 += c1;\rc2 += c1 += c1; 我们的目标是实现一组合格的操作符重载。\ninline complex\u0026amp; complex::operator += (const complex\u0026amp; r) {\rreturn __doapl(this, r);\r}\rinline complex\u0026amp; __doapl(complex* ths, const complex\u0026amp; r) {\rths-\u0026gt;re += r.re;\rths-\u0026gt;im += r.im;\rreturn *ths;\r} inline\r#\rinline牵扯到编译器认为此段代码何时应该展开的实现细节，很难在此论述它的含义，有兴趣可以去看gcc的实现\n__doapl的设计考量\r#\r这种设计目的是为了将goal和functional process分离，比如我要做A，A包括了2个很common的动作X和Y，那么X、Y都应当单独封装\ndo A() { X; Y; }\rdo X() {}\rdo Y() {} 类内和类外\r#\r众所周知，操作符重载还有另一种常见的形式\ninline complex operator+(const complex\u0026amp; x, const complex\u0026amp; y) {\rreturn complex(real(x) + real(y), image(x) + image(y));\r}\rcomplex c1, c2, c3;\rc2 = c1 + c2; 通过发现它和上部分的区别，产生问题：什么时候参数里有两个值，什么时候有一个值？c1 = c2 + c3 + c4和c1 += c2 += c3的处理逻辑会因为参数而改变么？\n这涉及this指针省略的问题，对于inline complex\u0026amp; complex::operator += (const complex\u0026amp; r)函数，编译器会将它认为是inline complex\u0026amp; complex::operator += (this, const complex \u0026amp; r)，因为它是类的成员函数，所以多了一个this，代表这个类的实例本身，所以c2 += c1，本质上还是两个参数，为什么只写一个参数是因为剩下的那个（隐藏的）参数代表自身。\n为什么操作符重载可以连续累加？\r#\r针对类内：为什么可以c1+=c2+=c1+=cn......，因为它的实现是返回一个complex\u0026amp;，假设不返回complex\u0026amp;而返回一个void，结果会导致：c1+=c2没有问题，但是c1+=c2+=c3会出现不能将空转换为complex\u0026amp;的错误。所以类内重载要用\u0026amp;，但是直接return by value也是可以的，用\u0026amp;只是因为性能考量。\n对于类外：基本不可以return by ref，因为生命周期会消失。\n// 合法，为什么？不知道\rinline complex\u0026amp; operator+ (const complex\u0026amp; x) {\rreturn x;\r}\rcout \u0026lt;\u0026lt; (+x) \u0026lt;\u0026lt; endl; // 不合法，因为必须返回本地对象，不能返回complex\u0026amp;\rinline complex\u0026amp; operator- (const complex\u0026amp; x) {\rreturn complex(-real(x), -image(x));\r}\r// 同不合法\rinline complex\u0026amp; operator+(const complex\u0026amp; x, const complex\u0026amp; y) 为什么重载\u0026lt;\u0026lt;需要在类外\r#\rinline complex conj(const complex \u0026amp;x ) {\rreturn complex(real(x), -image(x));\r}\rcout \u0026lt;\u0026lt; conj(c1) \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; conj(c1) \u0026lt;\u0026lt; conj(c2) \u0026lt;\u0026lt; endl; #include \u0026lt;iostream\u0026gt;\rostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; os, complex\u0026amp; c1) {\rreturn os \u0026lt;\u0026lt; \u0026#34;image\u0026#34; \u0026lt;\u0026lt; c1.image \u0026lt;\u0026lt; \u0026#34;real\u0026#34; \u0026lt;\u0026lt; c1.real;\r} 这个无法写成类函数，因为cout是一个ostream对象，标准库写好的，我们只能写成global，然后，按照ostream \u0026lt;\u0026lt; complex的结构，我们将第一个参数定义为ostream\u0026amp; os, \u0026amp;为了效率\n不能加const，因为加了const我们就没有办法写入这个ostream。 对于连续输出\u0026lt;\u0026lt;，本质是一个执行顺序的问题，从左到右，返回ostream\u0026amp;，（不存在ostream\u0026amp;对象在函数内销毁的问题，所以没必要输出ostream值类型） C++每一个部分都很烧脑，上述问题这算是一个难点之一。\n"},{"id":7,"href":"/docs/example/table-of-contents/os-review/","title":"操作系统中的进程和锁","section":"At School","content":"\rProcess\r#\r进程是执行中的程序，包括文本段（代码段），程序计数器，处理器寄存器内容，stack段（临时数据，函数参数，返回地址，局部变量），数据段（全局变量），heap段（动态内存）。 内存中的进程如如图所示： 进程在操作系统中以PCB表示，如图，有：\n进程状态：如图 Program Counter：下一个进程地址 CPU Register：累加器，索引寄存器，堆栈指针，通用寄存器，条件码寄存器（出现中断后要保存好） 调度信息：进程优先级，调度队列指针。 Memory Management：This information may include such information as the value of the base and limit registers, the page tables, or the segment tables, depending on the memory system used by the operating system Accounting: This information includes the amount of CPU and real time used, time limits, account numbers, job or process numbers, and so on. I/O: This information includes the list of I/O devices allocated to the process, a list of open files, and so on. 进程的切换如图所示。\nfork和exec\r#\r如图\n生产者消费者\r#\r操作系统概念一书在开始介绍了producer和consumer模式，其代码如下：\n// 生产者\rwhile (true) {\r/* produce an item in nextProduced */ while (counter == BUFFER SIZE); /* do nothing */ buffer[in] = nextProduced;\rin = (in + 1) % BUFFER SIZE; counter++;\r} 其定义了一个数组buffer，生产者会在in处更改一个项，然后将in向右移动1（即：移动到后面邻接的一个空元素），然后计数count增加一，当count是buffer size的时候，意味着不能再添加了，陷入一个死循环。直到消费者执行剔除操作。\n//消费者\rwhile (true) {\rwhile (counter == 0); /* do nothing */\rnextConsumed = buffer[out];\rout = (out + 1) % BUFFER SIZE; counter--;\r/* consume the item in nextConsumed */\r} 此两段代码的意义在于诠释两个进程对于一个区域的读和写，假设无lock的限制，会报错，比如增加五次数据然后删除五次数据结果发现count不是0的情况。 因为count++和count--的操作是分成三段进行的，即：register1 = counter ， register1 = register1 + 1 , counter = register1和register2 = counter, register2 = register2 − 1 , counter = register2。微观上进程间的调度会让这六句代码交替执行，导致count不是0。\n临界区的概念\r#\rdo {\rextry section\rcritical section\rexit section\rremainder section\r} while(1) 上述伪代码代表了一个通用的进程 \\(P_i\\)\r一般来讲会经历的多线程竞争情况\n操作系统概念上写到：\nConsider a system consisting of \\(n\\)\rprocesses \\({P_0, P_1,..., P_{n−1}}\\)\r. Each process has a segment of code, called a critical section, in which the process may be changing common variables, updating a table, writing a file, and so on. The important feature of the system is that, when one process is executing in its critical section, no other process is to be allowed to execute in its critical section. That is, no two processes are executing in their critical sections at the same time. The critical-section problem is to design a protocol that the processes can use to cooperate. Each process must request permission to enter its critical section. The section of code implementing this request is the entry section. The critical section may be followed by an exit section. The remaining code is the remainder section.\n临界区问题的解决需要满足三个条件：\n第一个条件是：mutual exclution，即不能有两个进程同时访问critical section。 第二个条件是：If no process is executing in its critical section and some processes wish to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which will enter its critical section next, and this selection cannot be postponed indefinitely. 这一段就是只有执行完remain section的进程才有资格决定进入critical section，且critical section中此时需要0进程，且此决定不能被postponed indefinitely。 第三个条件就是：bounded waiting，一个进入critical section的request不能被无限期推迟。 抢占式内核和非抢占式内核\r#\r非抢占内核不允许正在进行的process被打断，反之是抢占式内核。非抢占式内核不存在临界区问题。\npeterson\r#\rdo {\rflag[i] = true;\rturn = j;\rwhile (flag[j] \u0026amp;\u0026amp; turn = j);\r// critical section\rflag[i] = false;\r// remainder section\r} while(1) 假定有两个进程i，j。共同执行这段代码。flag[i]和flag[j]是两个bool值，标志着进程是否想进入临界区。 首先假设进程j正在critical section中，然后进程i首先执行flag[i] = true，表示i想进入临界区，之后将turn变为j。 i进程中，假设这个算法是可以的，那么while应该是一个死循环，可以得出flag[j]一定是true。 回到j进程，当j进程执行完临界区，执行flag[j] = false。 回到i进程的死循环里，这个循环松动，i进入critical section。 回到j进程，执行remainder section之后回到do while的开头，flag[j] = true，表明j要进临界区，turn是i，表明i正在用，之后进行死循环。重复往复。 这么设计的缘由是什么？ 做一下浅显的分析，假设两个进程互斥，那就意味着一定有一个相反的变量turn，turn本身是一个变量但是可以用进程号表示这种互斥的关系。那么如何能让turn交换呢？答案是当前进程改变它的值。\n以下是两个缺失判断条件的例子\n// 对于i\rdo {\rturn = j;\rwhile(turn == j);\r// 临界\r} while(1) // 对于j\rdo {\rturn = i;\rwhile(turn == i);\r// 临界\r} while(1) 假设只有i没有j，turn被i设为j，之后卡死直到j来解锁turn变为i，i进程解锁进入临界区，当i进行完临界区，turn变为j，i进程卡死，j进程进入临界区，往复这样是不行的，因为这样循环的触发条件是不满足的，不论第一个进程是i还是j，第一个进程永远是卡死的，要靠第二个进程来解锁。 所以这就是flag[i]和flag[j]存在的的必要，表明\u0026quot;我想要进入\u0026quot;，而不是仅仅是\u0026quot;现在到谁了\u0026quot;。这样第一个进入的进程的while不会是一个死循环。\n但是peterson并无引出锁的概念：书上有写，进程在进入临界区之前获得锁，退出临界区之后释放锁，但是这样还不够具体。在swap和testandset算法中，锁被当成了一个具体的实例。\nswap \u0026amp;\u0026amp; testandset\r#\rswap和testandset是基于硬件实现的临界区算法\n// test and set\rbool ts(bool* lock) {\rbool old;\rold = *lock;\r*lock = true;\rreturn old;\r}\rdo {\rwhile(ts(\u0026amp;lock)) {\r// do nothing }\rlock = false;\r} while(1) 这样发现lock变成了一个可以原子操作的实体（由硬件实现），swap算法不赘述了，和ts差不多只不过变成了两个指针的swap操作，三种临界区算法的共同缺点就是会在中间的while()这里忙等空转，也就是虽然说满足了mutually exclusion但是不满足bounded waiting，下面是ts算法中解决bounded waiting的办法。\ndo {\rwaiting[i] = true\rkey = true\rwhile (waiting[i] \u0026amp;\u0026amp; key) {\rkey = testandset(\u0026amp;lock)\r}\rwaiting[i] = false\r// 临界\rj = (i + 1) % n\rwhile ((j != i) \u0026amp;\u0026amp; !waiting[j]) {\rj = (j + 1) % n\r}\rif (i == j) {\rlock = false\r} else {\rwaiting[j] = false\r}\r// remainder\r} while(1) 有兴趣自行研究，过于复杂不赘述\nsemaphore\r#\r// wait()\rwait(s) {\rwhile(s \u0026lt;= 0) {}\rs--;\r} // signal()\rsignal(s) {\rs++;\r} 基于硬件的临界区算法的伪码并不直观，于是封装成semaphore这种形式以方便理解\n信号量就是那个s，信号量有两种，第一种是binary semaphore，第二种是counting semaphore，前者是01两种数字的s，后者可以是任意数，binary semaphore也叫做mutex lock（互斥锁），counting semaphore可以规定很多的资源，每用一个资源，s--\nspin lock\r#\r上述的lock叫做spinlock，因为会在while()循环里死循环，所以叫做自旋锁，它的缺点就是忙等（busy waiting），浪费cpu，多核cpu里面会让另外一个cpu做忙等，另外一个做正常任务。这种也不是全都是缺点，因为这样避免了多余的context switch。\n去解决忙等的问题，要采用以下的方式：\n信号量并没有本质上解决busy waiting的问题，但是可以将那个while的死循环变成block操作，即\ntypedef struct{ int value;\rstruct process *list; } semaphore; 这是一个结构体，里面的value是可以用的资源数，list是等待队列，存放pcb\nwait(semaphore *S) { S-\u0026gt;value--;\rif (S-\u0026gt;value \u0026lt; 0) {\radd this process to S-\u0026gt;list;\rblock();\r}\r} signal(semaphore *S) { S-\u0026gt;value++;\rif (S-\u0026gt;value \u0026gt;= 0) {\rremove a process P from S-\u0026gt;list; wakeup(P);\r} } 当资源数不共用的时候会进入休眠，然后当资源够用的时候解锁，然后在list里取出pcb，也可能不是立刻马上取出，而是交给操作系统调度（操作系统决定是不是马上要调度到这个pcb），这样本质上还是没有解决忙等的问题，因为只是将忙等从entry section 移动到了critical section ，但是这样，也是快了很多，大部分情况下消除了busy waiting。而且wait和signal也要将内部实现为一个自旋锁，来保证atomic operation。\ndead lock\r#\r// p1\rwait(q);\rwait(s); // p2\rwait(s);\rwait(q); 当p1和p2同时执行的时候（先p1的第一句之后p2的第一句或者相反），p1要wait(s)因为s被p2耗光了，p2要等q因为p1耗光了q。这样就卡住了。\n进程的优先级继承\r#\r假定三个进程优先级顺序为：l \u0026lt; m \u0026lt; h\n首先l访问内核资源r，h也想访问，因为l在代码前段，所以等l访问完再访问，但是这个时候抢占进程m抢了l，m的时长将决定h什么时候访问的到r，这样显然是不对的，因为h的优先级是最大的。\n解决办法是所有正在访问较高优先级进程所需资源的进程都将继承较高优先级，直到它们用有关资源完成为止。因为h要用l对r的计算结果，所以l暂时的优先级将会变成h，之后再退回去。\nFirst / Second Reader And Writer Problem\r#\rfirst reader and writer problem是写操作优先于读操作。\nsecond reader and writer problem是当writer正在等reader的时候，其他reader就不要再添加到writer前面了。\n假设对于第一种情况，假设读操作没完没了，那么writer就会starvation。反之第二种情况，reader会starvation。\nread write lock\r#\r// read\rlock(c) {\rc++;\rif(c == 1) {\rlock(g);\r} }\runlock(c);\r// 临界区\r// 退出读\rlock(c) {\rc--;\rif(c == 0) {\runlock(g);\r}\r}\runlock(c); // 写\rlock(g);\r// 临界区。\r// 退出写\runlock(g); 先绕开读写锁的代码操作，首先对于读一个变量和写一个变量，需要一个lock(g)，g代表全局变量，一个读进程和一个写进程都可以对这个g进行lock和unlock。其次counter记录有几个被阻塞的读线程。计作c。c = 0；按照以往的经验，为了保证寄存器不会乱赋值，要对c进行加锁：lock(c)\n上面两段代码的效果是：\n假设先来了一个读进程，counter锁住，counter自增到1，全局变量锁住，counter解锁，开始读。之后在上面进程读的时候又来一个进程，它们会一起读么？会，锁住c，c自增到2，跳过那个if（不重复lock g），unlock counter后一起读。假设突然来了一个写进程，它会等这一堆读进程完了再写。\n即：等g被读进程们解锁了再写。假设之后来了个读进程，它会插到这个写进程前面么？不会，因为写进程第一行有个lock(g)，这样达到了read write lock的效果。\n但是以上读写操作都有可能starvation，没有调度算法的后果就是这样。\n综上，读写锁，是两把互斥锁的结合。\n"},{"id":8,"href":"/docs/example/table-of-contents/smart_pointer/","title":"智能指针","section":"At School","content":"\r智能指针\r#\runique_ptr\r#\r允许指针有一个所有权，用unique ptr作为首选，除非你知道你确定要用shared ptr。unique ptr的所有权可以被移给一个新的owner，但是不能copied or shared。shared ptr旨在替换废弃的auto ptr，unique ptr比boost库的scoped ptr要好，它的尺寸仅占一个指针的位置且支持右值引用（为了插入删除获取快一些）\nshared_ptr\r#\r引用计数的指针，Use when you want to assign one raw pointer to multiple owners，用这个。\n比如当返回一个指针的copy的时候（并保留原来的），这个时候，就要用shared ptr，此指针不会被删除，直到它的shared_ptr离开作用域之外。\n它的尺寸是两个指针大小，第一块是为了储存那个对象，第二块是shared control block，包含引用计数。\nweak_ptr\r#\r和shared ptr搭配的指针，一个weak ptr给一个被多个shared ptr指针指向的对象提供访问的通道，但是并不参与reference counting。\nSpecial-case smart pointer for use in conjunction with shared_ptr. A weak_ptr provides access to an object that is owned by one or more shared_ptr instances, but does not participate in reference counting. Use when you want to observe an object, but do not require it to remain alive. Required in some cases to break circular references between shared_ptr instances. Header file: \u0026lt;memory\u0026gt;. For more information, see How to: Create and Use weak_ptr Instances and weak_ptr Class.\nmsdn对smart pointer的介绍\r#\r在现代C++编程中，标准库，包含了smart pointer，使得开发者确保程序没有内存（资源）泄漏和exception-safe。\n智能指针，定义在std命名空间的memory头文件里的，它们是raii的关键（资源获取即初始化）。raii的主要目的是对象的初始化和资源的获取在同一时刻进行，所以所有对象的资源的创建是一行代码就解决的。\nraii的原则是给所有堆初始化的资源以所有权，比如：动态分配的内存或者系统对象的句柄和在stack上分配的对象，其析构函数包含有delete函数和free函数的代码。\n大多数情况下，当你初始化一个raw pointer或者资源句柄去指向一个真的资源时，请立刻停止并改使智能指针。在现代C++中，裸指针仅仅被用于小型代码区、块、极端的性能优化（没有办法用智能指针的时候）\nvoid UseRawPointer()\r{\r// Using a raw pointer -- not recommended.\rSong* pSong = new Song(L\u0026#34;Nothing on You\u0026#34;, L\u0026#34;Bruno Mars\u0026#34;); // Use pSong...\r// Don\u0026#39;t forget to delete!\rdelete pSong; }\rvoid UseSmartPointer()\r{\r// Declare a smart pointer on stack and pass it the raw pointer.\runique_ptr\u0026lt;Song\u0026gt; song2(new Song(L\u0026#34;Nothing on You\u0026#34;, L\u0026#34;Bruno Mars\u0026#34;));\r// Use song2...\rwstring s = song2-\u0026gt;duration_;\r//...\r} // song2 is deleted automatically here. 如上述例子，smart pointer是stack上的class template，用raw pointer初始化，这个raw pointer指向堆内存的对象。\n智能指针初始化后，它就有了这个raw pointer的所有权。这表示，smart pointer负责析构raw pointer指向的那个内存。智能指针的析构函数包含了delete的调用，因为智能指针在stack上被声明，它的析构函数在其脱离其作用域时会被自动调用，even if an exception is thrown somewhere further up the stack.\n访问这种封装好的指针要用-\u0026gt;操作符，which，智能指针类重载了-\u0026gt;然后返回了被封装的raw pointer。\nC++智能指针类似于C#中对象的创建习惯，创建一个对象然后让系统take care of its deleting at the correct time，区别是，C++无在后台跑的GC，内存是由作用域管理的，更快。\n记住永远不要用parameter list来初始化智能指针，智能指针永远“单独创建一行”（不理解parameter list是那个list）\nAlways create smart pointers on a separate line of code, never in a parameter list, so that a subtle resource leak won\u0026rsquo;t occur due to certain parameter list allocation rules.\nclass LargeObject\r{\rpublic:\rvoid DoSomething(){}\r};\rvoid ProcessLargeObject(const LargeObject\u0026amp; lo){}\rvoid SmartPointerDemo()\r{ // Create the object and pass it to a smart pointer\rstd::unique_ptr\u0026lt;LargeObject\u0026gt; pLarge(new LargeObject());\r//Call a method on the object\rpLarge-\u0026gt;DoSomething();\r// Pass a reference to a method.\rProcessLargeObject(*pLarge);\r} //pLarge is deleted automatically when function block goes out of scope. （综上我们可以看出，它传参传的是智能指针的const引用）\n此例解释了如何使用智能指针\n声明此指针为局部变量而不是用new或者malloc 在\u0026lt;\u0026gt;里规定封装指针指向的类型 在构造函数里放入裸指针的新对象 用重载操作符*或者-\u0026gt; 智能指针基本和裸指针差不多大，四个字节或者八个，性能也是。 智能指针自己的的成员函数要用\u0026quot;dot\u0026quot;来访问\n在变量离开作用域之前，有些智能指针可以用reset释放所有权来free memory，如下：\nvoid SmartPointerDemo2()\r{\r// Create the object and pass it to a smart pointer\rstd::unique_ptr\u0026lt;LargeObject\u0026gt; pLarge(new LargeObject());\r//Call a method on the object\rpLarge-\u0026gt;DoSomething();\r// Free the memory before we exit function block.\rpLarge.reset();\r// Do some other work...\r} Smart pointers usually provide a way to access their raw pointer directly. C++ Standard Library smart pointers have a get member function for this purpose, and CComPtr has a public p class member. By providing direct access to the underlying pointer, you can use the smart pointer to manage memory in your own code and still pass the raw pointer to code that does not support smart pointers.（大概是有一个get()方法可以拿到裸指针，然后CComPtr估计是MS黑魔法）\nvoid SmartPointerDemo4()\r{\r// Create the object and pass it to a smart pointer\rstd::unique_ptr\u0026lt;LargeObject\u0026gt; pLarge(new LargeObject());\r//Call a method on the object\rpLarge-\u0026gt;DoSomething();\r// Pass raw pointer to a legacy API\rLegacyLargeObjectFunction(pLarge.get()); } How to: Create and use unique_ptr instances\r#\r这个例子展示了什么叫做用move来转移所有权，而不是将指针assign给另一个指针。\nunique_ptr\u0026lt;Song\u0026gt; SongFactory(const std::wstring\u0026amp; artist, const std::wstring\u0026amp; title)\r{\r// Implicit move operation into the variable that stores the result.\rreturn make_unique\u0026lt;Song\u0026gt;(artist, title);\r}\rvoid MakeSongs()\r{\r// Create a new unique_ptr with a new object.\rauto song = make_unique\u0026lt;Song\u0026gt;(L\u0026#34;Mr. Children\u0026#34;, L\u0026#34;Namonaki Uta\u0026#34;);\r// Use the unique_ptr.\rvector\u0026lt;wstring\u0026gt; titles = { song-\u0026gt;title };\r// Move raw pointer from one unique_ptr to another.\runique_ptr\u0026lt;Song\u0026gt; song2 = std::move(song);\r// Obtain unique_ptr from function that returns by value.\rauto song3 = SongFactory(L\u0026#34;Michael Jackson\u0026#34;, L\u0026#34;Beat It\u0026#34;);\r} void SongVector()\r{\rvector\u0026lt;unique_ptr\u0026lt;Song\u0026gt;\u0026gt; songs;\r// Create a few new unique_ptr\u0026lt;Song\u0026gt; instances\r// and add them to vector using implicit move semantics.\rsongs.push_back(make_unique\u0026lt;Song\u0026gt;(L\u0026#34;B\u0026#39;z\u0026#34;, L\u0026#34;Juice\u0026#34;)); songs.push_back(make_unique\u0026lt;Song\u0026gt;(L\u0026#34;Namie Amuro\u0026#34;, L\u0026#34;Funky Town\u0026#34;)); songs.push_back(make_unique\u0026lt;Song\u0026gt;(L\u0026#34;Kome Kome Club\u0026#34;, L\u0026#34;Kimi ga Iru Dake de\u0026#34;)); songs.push_back(make_unique\u0026lt;Song\u0026gt;(L\u0026#34;Ayumi Hamasaki\u0026#34;, L\u0026#34;Poker Face\u0026#34;));\r// Pass by const reference when possible to avoid copying.\rfor (const auto\u0026amp; song : songs)\r{\rwcout \u0026lt;\u0026lt; L\u0026#34;Artist: \u0026#34; \u0026lt;\u0026lt; song-\u0026gt;artist \u0026lt;\u0026lt; L\u0026#34; Title: \u0026#34; \u0026lt;\u0026lt; song-\u0026gt;title \u0026lt;\u0026lt; endl; } } 注意在循环里如果不用\u0026amp;会报错，因为unique_ptr的copy contructor是默认没有的\n// Create a unique_ptr to an array of 5 integers.\rauto p = make_unique\u0026lt;int[]\u0026gt;(5);\r// Initialize the array.\rfor (int i = 0; i \u0026lt; 5; ++i)\r{\rp[i] = i;\rwcout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; endl;\r} 上述例子给int*（int[]）做了一个智能指针，五个单位长度的数组，我们可以看出，初始化一个智能指针\u0026lt;\u0026gt;里可以放一个类，然后用new关键字在后面（代表一个这个类一个智能指针），还有另外一种就是\u0026lt;\u0026gt;里放一个数组，然后()里放你要几个长度的数组，访问这个指针可以用array[i]这样访问，也就是说智能指针给数组单独做了一套机制。\n"},{"id":9,"href":"/docs/example/table-of-contents/type-casting-zh/","title":"浅谈C++中的类型转换","section":"At School","content":"\rimplicit conversation overview\r#\rimplicit conversion: int to short, short to int, short to bool, float to bool \u0026hellip;. (without explicit converter), also called standard conversion.\nconverting type such as int to float is known as promotion, is guaranteed to produced the same value in the destination type otherwise, may not always be able to represent the same value exactly (丢失精度问题，编译器会发出警告，可以通过explicit conversion去消除) for non-fundamental types: arrays and functions implicitly convert to pointers pointers in general allow the following conversions: Null pointers can be converted to pointers of any type Pointers to any type can be converted to void pointers. Pointer upcast: pointers to a derived class can be converted to a pointer of an accessible and unambiguous base class, without modifying its const or volatile qualification. (子类指针可以转父类) #include \u0026lt;iostream\u0026gt;\rusing namespace std;\rclass A {};\rclass B {\rpublic:\r// conversion from A (constructor):\rB (const A\u0026amp; a) {}\r// conversion from A (assignment):\rB\u0026amp; operator= (const A\u0026amp; a) {\rreturn *this;\r}\r// conversion to A (type-cast operator)\roperator A() {\rreturn A();\r}\r}; int main ()\r{\rA foo;\rB bar = foo; // calls constructor\rbar = foo; // calls assignment\rfoo = bar; // calls type-cast operator\rreturn 0;\r} 浅析一下上述官网的例子，构造函数的调用，A foo调用了A类默认的构造函数，B bar = foo;这个是调用了自己实现的拷贝构造函数B (const A\u0026amp; a) {}，然后bar = foo;调用了B\u0026amp; operator=(const A\u0026amp; a) { return *this; }，这个是一个针对等号的二元运算符重载，传入参数是const A\u0026amp; a，对应的是等号的右边，然后返回类型B\u0026amp;对应等号的左边，因为B bar是已存的，所以可以接受一个带引用的返回值B\u0026amp;，这种叫做assignment也就是赋值，也就是说，赋值的本质就是默认的或者不是默认的类内=操作符重载\ntype cast operator\r#\r#include \u0026lt;iostream\u0026gt;\rclass D {\rpublic: D(double d) : d_(d);\roperator int() const {\rstd::cout \u0026lt;\u0026lt; \u0026#34;int d is called\u0026#34; \u0026lt;\u0026lt; std::endl;\rreturn static_cast\u0026lt;int\u0026gt;(d_);\r}\rprivate:\rdouble d_;\r};\rint add(int a, int b) {\rreturn a + b;\r}\rint main() {\rD d1 = 1.1;\rD d2 = 1.2;\rstd::cout \u0026lt;\u0026lt; add(d1, d2) \u0026lt;\u0026lt; std::endl;\r} 如上所示，type cast operator将类转换为对应的int\ntips\r#\r构造函数不返回值，拷贝构造函数不返回值 拷贝构造函数的调用： 当参数的时候 当返回值的时候 A a = b; A a(b); 上述例子叫做assignment而不是copy T t1; T t2 = t1; 这是是copy不是assignment，而T t1; T t2; t2 = t1; ，这是assignment而不是copy 默认的运算符=是浅拷贝，默认的构造函数也是浅拷贝，二者的区别在于T t1; T t2; t2 = t1;的赋值场景必须是建立在源对象与目标对象均已声明的基础上；而拷贝构造函数的赋值，必须是针对新创建对象的场景。 explicit\r#\r// explicit:\r#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rclass A {};\rclass B {\rpublic:\rexplicit B (const A\u0026amp; x) {}\rB\u0026amp; operator= (const A\u0026amp; x) {return *this;}\roperator A() {return A();}\r};\rvoid fn (B x) {}\rint main ()\r{\rA foo;\rB bar (foo);\rbar = foo;\rfoo = bar;\r// fn (foo); // not allowed for explicit ctor.\rfn (bar); return 0;\r} 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换 explicit关键字只能用于类内部的构造函数声明上。 explicit关键字作用于单个参数的构造函数。 下述main里的三行Circle全都是implicit conversion\nclass Circle {\rpublic:\rCircle(double r) : R(r) {} Circle(int x, int y = 0) : X(x), Y(y) {}\rCircle(const Circle\u0026amp; c) : R(c.R), X(c.X), Y(c.Y) {} private:\rdouble R;\rint X;\rint Y;\r};\rint main() {\rCircle A = 1.23; Circle B = 123;\rCircle C = A; } class Circle { public: explicit Circle(double r) : R(r) {} explicit Circle(int x, int y = 0) : X(x), Y(y) {} explicit Circle(const Circle\u0026amp; c) : R(c.R), X(c.X), Y(c.Y) {} private: double R; int X; int Y; }; int _tmain(int argc, _TCHAR* argv[]) { //3句都会报错 //Circle A = 1.23; //Circle B = 123; //Circle C = A; //只能用显示的方式调用了 //未给拷贝构造函数加explicit之前可以这样 Circle A = Circle(1.23); Circle B = Circle(123); Circle C = A; //给拷贝构造函数加了explicit后只能这样了 Circle A(1.23); Circle B(123); Circle C(A); return 0; } 加了explicit关键字后，可防止以上隐式类型转换发生，不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字\ntype casting\r#\rC++ is a strong-typed language. Many conversions, specially those that imply a different interpretation of the value, require an explicit conversion, known in C++ as type-casting. There exist two main syntaxes for generic type-casting: functional and c-like:\ndouble x = 10.3;\rint y;\ry = int (x); // functional notation\ry = (int) x; // c-like cast notation // class type-casting\r#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rclass Dummy {\rdouble i,j;\r};\rclass Addition {\rint x,y;\rpublic:\rAddition (int a, int b) { x=a; y=b; }\rint result() { return x+y;}\r};\rint main () {\rDummy d;\rAddition * padd;\rpadd = (Addition*) \u0026amp;d;\rcout \u0026lt;\u0026lt; padd-\u0026gt;result();\rreturn 0;\r} The program declares a pointer to Addition, but then it assigns to it a reference to an object of another unrelated type using explicit type-casting: padd = (Addition*) \u0026amp;d; Unrestricted explicit type-casting allows to convert any pointer into any other pointer type, independently of the types they point to. The subsequent call to member result will produce either a run-time error or some other unexpected results.\n不加限制的类型转换可以任意乱转，就如同上面的例子一样，Dummy类和Addition类没有任何关系，但是我们定义了一个Addition类型的指针、一个普通的Dummy对象d，然后取d的指针，在\u0026amp;d左边加上(Addition*) ，这样竟然就可以赋值给一个Addition的指针变量了，显然这是不对的。\nconst cast的一些坑\r#\r// const_cast\r#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rvoid print (char * str)\r{\rcout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\r}\rint main () {\rconst char * c = \u0026#34;sample text\u0026#34;;\rprint ( const_cast\u0026lt;char *\u0026gt; (c) );\rreturn 0;\r} 以上是cpp官网的例子，它的意思是一个const char* 变量可以用const cast去掉const限制来符合某些函数的参数限制\n刚碰编程的初学者可能会尝试以下语句\nconst int cst = 10;\rint temp = cst;\rtemp = 20; 要更改const int型变量cst的值，觉得改了temp, cst就会改变，实则不会\n即使用了指针改，也是不对的\nconst int cst = 10;\rint *temp = \u0026amp;cst;\r*temp = 20; 编译器会说 Error: invalid conversion from 'const int*' to 'int*'，也就是说const int取\u0026amp;地址之后是一个const int *而不是int *, const int *也是不可改的，注意c语言是可以这样改但是会给一个warning，而c++不可以\nconst int cst = 10;\rint\u0026amp; temp = cst;\rtemp = 20; 那么假设用引用可以么？依然不可以，会报错成Error: invalid initialization of reference of type 'int\u0026amp;' from expression of type 'const int'，对于c语言，c语言没有引用只有取地址\u0026amp;，这两种情况报错的语法问题上, 一个是invalid conversion from x to y, 一个是invalid initialization of ref x of type x。\n那么如何更改一个const的值呢？c系语言的优点在于任意指针可以转换成彼此，这样就不存在一个const int*不能赋值给int*的问题了，参考上述中Dummy类指针甚至可以转成一个和它毫无关系的类，const指针也是可以的\nconst int constant = 10;\rint* modifier = (int*)(\u0026amp;constant); 等同于const cast\nconst int constant = 21;\rconst int* const_p = \u0026amp;constant;\rint* modifier = const_cast\u0026lt;int*\u0026gt;(const_p);\r*modifier = 7; 运行打印constant的时候，却发现依旧是21，打印*const_p的时候也是21，然后打*modifiler却是7，即使这三个的地址全都是一个地址。\n#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rint main()\r{\rconst int a = 10;\rconst int* pa = \u0026amp;a;\rint* pb = (int*)pa;\r*pb = 100;\rcout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; *pb \u0026lt;\u0026lt; endl;\rreturn 0;\r} 同样这个例子第一个输出的是100，第二个输出的是10\n鉴于上述几段例子是某博客扒下来的，那篇blog的评论区有人指出在vs2008环境下，debug中值是改了的，楼主用的是xcode，我那个例子用的是online gdb（const值被改了，我们假定的是const不被改），有人指出在调试中是这样，最后结果仍然是楼主的吻合的（const最后输出结果没被改但是调试中被改了），有人评论指出是编译器的问题，编译器识别出const int xxx = 100;，然后结尾cout \u0026lt;\u0026lt; x;的时候不论如何编译器都当作100输出（常量折叠），但是编译为了检查上下文整体语法只能将计就计的逐个编译，又有人指出int a = 100; const int b = a;可以避免常量折叠，这就是编译器实现的问题。不过已经没有深究的必要了。总之，不要尝试给一个const*变量去掉const*赋值。\nstatic cast\r#\rstatic_cast can perform conversions between pointers to related classes, not only upcasts (from pointer-to-derived to pointer-to-base), but also downcasts (from pointer-to-base to pointer-to-derived). No checks are performed during runtime to guarantee that the object being converted is in fact a full object of the destination type. Therefore, it is up to the programmer to ensure that the conversion is safe. On the other side, it does not incur the overhead of the type-safety checks of dynamic_cast.\nstatic_cast可以在指向相关类的指针之间执行转换，不仅是向上精度的转换（父类指针-\u0026gt;子类指针），而且可以是(子类指针-\u0026gt;父类指针), 运行时无“是否检查你这个对象是否彻彻底底对的上你要的对象”的检查，没有dynamic_cast那种安全检查\n比如下述代码是合法的\nclass Base {};\rclass Derived: public Base {};\rBase * a = new Base;\rDerived * b = static_cast\u0026lt;Derived*\u0026gt;(a); This would be valid code, although b would point to an incomplete object of the class and could lead to runtime errors if dereferenced. （这是一段合法的代码，尽管b对不上a）\nTherefore, static_cast is able to perform with pointers to classes not only the conversions allowed implicitly, but also their opposite conversions.\nConvert from void* to any pointer type. In this case, it guarantees that if the void* value was obtained by converting from that same pointer type, the resulting pointer value is the same.\n如下：\nint i, j;\rdouble slope = static_cast\u0026lt;double\u0026gt;(j) / i;\rvoid *p = \u0026amp;d;\rdouble *dp = static_cast\u0026lt;double*\u0026gt;(p); Convert integers, floating-point values and enum types to enum types. （int，float转enum） reinterpret_cast\r#\r用reinterpret_cast对指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用。\n"},{"id":10,"href":"/docs/example/table-of-contents/sliding_windows_prot/","title":"滑动窗口","section":"At School","content":"\r滑动窗口\r#\r滑动窗口的净代码量不超过十行，但是这十行废了我两天的功夫还没搞清楚\nclass Solution {\rpublic:\rint lengthOfLongestSubstring(string s) {\rif(s.length() == 0) {\rreturn 0;\r}\rint left = 0;\rint right = 0;\rint res = 0;\rvector\u0026lt;int\u0026gt; char_vec(128, -1);\rwhile(right \u0026lt;= s.length() - 1) {\rchar right_char = s[right];\rint index = char_vec[right_char];\rif(index != -1 \u0026amp;\u0026amp; index \u0026gt;= left \u0026amp;\u0026amp; index \u0026lt;= right) {\rleft = index + 1;\r}\rres = max(res, right - left + 1);\rchar_vec[right_char] = right;\r++right;\r}\rreturn res;\r}\r}; 上面是lc上别人已经ac的答案，我们来顺一遍当输入是abcabcbb时是怎么个情况。\n第一轮迭代，right = 0, right_char = a, index是vector中第\u0026quot;a\u0026quot;个所在的值 = -1, res = max(0, 1) = 1, vector中第\u0026quot;a\u0026quot;个所在的值更新为right即为0, right++为1\n第二轮迭代，right = 1, right_char = b, index是vector中第\u0026quot;b\u0026quot;个所在的值 = -1, res = max(1, 2) = 2, vector中第\u0026quot;b\u0026quot;个所在的值更新为right即位1, right++为2\n第三轮，right = 2, right_char = c, index = -1, res = max(2, 3) = 3, ector中第\u0026quot;b\u0026quot;个所在的值更新为right即位2, right++为3\n第四轮，right = 3, right_char = a, index为0, 因为left是0，right是3, left=index+1 = 1, res = max(3, 3) = 3, vec[a] = 3, right = 4\nwhile(遍历s) {\rindex = hash_map[s[i]]\rif(can found s[i] in hash map且index 属于[left, right]) {\rleft = index + 1; }\rhas_map[s[i]] = right // right++是遍历条件\r} res的确是第三题要的结果（字串长度），但是实际上和其他变量都无关，只有right和left是最重要的\n"},{"id":11,"href":"/docs/example/table-of-contents/rawp/","title":"裸指针和其修饰字","section":"At School","content":"\r指针的定义\r#\r指针的定义：指针是存储对象内存地址的变量\nC和C++指针的用法有：\n分配堆内存的新对象 向一个函数传递另外一个函数 迭代数组或其他数据结构中的元素 在C风格的编程中，裸指针适用于上述三种描述。但是裸指针是导致很多问题的元凶，因此除非在有显著性能优势且清楚在删除对象时哪个指针有最终的所有权时，不要用裸指针。\u0026mdash;-msdn\n现代C++提供智能指针来负责分配对象、迭代器和遍历数据结构们，以及传递函数时使用的lambda表达式。\n裸指针\r#\r指针是变量，它存储对象在内存中的地址，它也用于访问对象。裸指针的定义是：生命周期不受封装对象控制的指针，这不同于智能指针。裸指针可以被赋值为另一个非指针变量的地址，或者可以被赋值为nullptr，未被赋值的裸指针随机被赋值一个地址。 指针可以被取消引用（dereference），返回它指向的对象值。\nint* p = nullptr; // declare pointer and initialize it\r// so that it doesn\u0026#39;t store a random address\rint i = 5;\rp = \u0026amp;i; // assign pointer to address of object\rint j = *p; // dereference p to retrieve the value at its address 一个指针可以指向一个有类型的对象或者void。当一个程序在heap分配对象时，它接收这个对象的地址（以指针的形式），如此的指针叫做owing pointer，一个owing pointer（or a copy of it），在不再需要那个heap object的时候，必须显式的free掉这个指针。否则就会内存泄漏，即此内存的地址没法给任何其他的程序去用了。用new分配出来的内存必须搭配delete或者delete[]。\nMyClass* mc = new MyClass(); // allocate object on the heap\rmc-\u0026gt;print(); // access class member\rdelete mc; // delete object (please don\u0026#39;t forget!) 一个指针，假设没有被声明为const指针，那么就可以自增或者自减到内存中的其他位置，这种操作叫做指针的算术运算。在C语言中，数组的迭代（或其他数据结构）会用到这种运算。const指针不能变更到内存的其他位置。 在六十四位的操作系统中，指针就有六十四个bit，一个指针的尺寸决定于它的可寻址空间有多少。所有指针的拷贝都指向同一个内存地址，指针（同引用）在C++程序中经常被用于传递对象的地址（而不是传递整个大对象），当定义一个函数的时候，规定指针参数为const，除非你想改这个对象，但是实际上，常引用比常量指针更常用于传递参数，除非此对象的值是nullptr。\n指针和数组有很大的关联，当一个数组在函数传参的时候，它传递的是第一个元素的地址\n#include \u0026lt;iostream\u0026gt;\rvoid func(int arr[], int length)\r{\r// returns pointer size. not useful here.\rsize_t test = sizeof(arr);\rfor(int i = 0; i \u0026lt; length; ++i)\r{\rstd::cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\r}\r}\rint main()\r{\rint i[5]{ 1,2,3,4,5 };\r// sizeof(i) = total bytes\rint j = sizeof(i) / sizeof(i[0]);\rfunc(i,j);\r} sizeof操作符返回数组有几个bytes，除以一个元素的sizeof就是数组的长度，当一个数组被当成参数的时候，会变成一个指针，sizeof一个指针对于x86机器来说返回四个byte，对于x64机器来说返回8个byte。 指针的算数运算可以用在非const指针让它们指向其它内存地址，指针可以用++, +=, -=, --来自增或者自减，这种方法在没类型的数据面前特别有用，比如void*指针会自增一个byte，一个有类型的指针按照它指向的值的 sizeof自增。\nPointers to functions\r#\r允许函数被传递到其他函数中，在C语言中称作call backs，现代 C++ 转而使用lambda表达式。\nvoid* pointer\r#\rA pointer to void simply points to a raw memory location. Sometimes it\u0026rsquo;s necessary to use void* pointers, for example when passing between C++ code and C functions.\nWhen a typed pointer is cast to a void pointer, the contents of the memory location are unchanged. However, the type information is lost, so that you can\u0026rsquo;t do increment or decrement operations. A memory location can be cast, for example, from MyClass* to void* and back again to MyClass*. Such operations are inherently error-prone and require great care to avoid errors.\nModern C++ discourages the use of void pointers in almost all circumstances.\npointer to function\r#\rIn C-style programming, function pointers are used primarily to pass functions to other functions. This technique allows the caller to customize the behavior of a function without modifying it. In modern C++, lambda expressions provide the same capability with greater type safety and other advantages.\nA function pointer declaration specifies the signature that the pointed-to function must have:\n// Declare pointer to any function that...\r// ...accepts a string and returns a string\rstring (*g)(string a);\r// has no return value and no parameters\rvoid (*x)();\r// ...returns an int and takes three parameters\r// of the specified types\rint (*i)(int i, string s, double d); const和volatile\r#\rconst和volatile关键字改变了系统对待指针的方式，const指针规定在初始化之后其值不能被修改，也就是说指针被保护以至于不能被修改。volatile关键字规定了值可以被其他程序改变的变量（多线程？）因此，volatile关键字用于声明shared memory中可以被多线程修改的或者全局的数据（用于沟通的、用于interrupt service routines的） 当一个变量被声明为volatile时，每一次程序要访问这个变量时，编译器都从内存重新读取它的值，这样显著的减少了编译器优化，however，当变量的状态可以不寻常的改变时，这是唯一允许这个程序可以正常运行的方式。请参阅这个博客和这个博客\nTo declare the object pointed to by the pointer as const or volatile, use a declaration of the form: 要将指针指向的对象声明为const或volatile，请使用以下形式的声明：\nconst char *cpch;\rvolatile char *vpch; To declare the value of the pointer — that is, the actual address stored in the pointer — as const or volatile, use a declaration of the form:\n声明指针的值-也就是说，实际的地址存在了指针里而不是指针指向的对象里时，用这个声明。\nchar * const pchc;\rchar * volatile pchv; 两种声明↑，留意\n"},{"id":12,"href":"/docs/example/after-school/","title":"After School","section":"Contents Post","content":"\rAbout\r#\rThose blog-posts written after I graduated.\n"},{"id":13,"href":"/docs/example/table-of-contents/","title":"At School","section":"Contents Post","content":"\rAbout\r#\rThose blog-posts written before I graduated.\n"},{"id":14,"href":"/docs/example/after-school/meaning-of-work/","title":"上班的意義","section":"After School","content":"\r上班的意義就在於上他****\r#\r"},{"id":15,"href":"/docs/example/after-school/2023scc/","title":"个人数据的标准合同条款","section":"After School","content":" 以下为20年新版gdpr协议下scc的控制者到处理者的中文翻译，不包含2个annex\nStandard Contractual Clauses for the transfer of personal data (controller / processor)\r#\r个人数据传输的标准合同条款（从控制者到处理者）\r#\rSECTION I 第一部分\r#\rClause 1\r#\rPurpose and scope 目的和范围\r#\r(a)\tThe purpose of these standard contractual clauses is to ensure compliance with the requirements of Regulation (EU) 2016/679 of the European Parliament and of the Council of 27 April 2016 on the protection of natural persons with regard to the processing of personal data and on the free movement of such data (General Data Protection Regulation) for the transfer of personal data to a third country. 该标准合同条款的目的是为了确保个人数据向第三国转移中，遵守欧洲议会和欧盟理事会2016年4月27日2016/679号条例（通用数据保护条例）规定的与处理个人数据和该等数据的自由流动有关的保护自然人的要求。\n(b)\tThe Parties:\n(i)\tthe natural or legal person(s), public authority/ies, agency/ies or other body/ies (hereinafter ‘entity/ies’) transferring the personal data, as listed in Annex I.A (hereinafter each ‘data exporter’), and 附件I.A.列举的转移个人数据的自然人或法人、公共机构、代理机构或其他实体（以下简称“实体”）（统称为“数据出口方”），和\n(ii)\tthe entity/ies in a third country receiving the personal data from the data exporter, directly or indirectly via another entity also Party to these Clauses, as listed in Annex I.A (hereinafter each ‘data importer’) 附件I.A.列举的从数据出口方接收个人数据的位于第三国的实体，通过另一方实体直接或间接地接收数据方也为合同一方（统称为“数据进口方”）。 have agreed to these standard contractual clauses (hereinafter: ‘Clauses’). 就标准合同条款（以下简称“条款”）协商一致。\n(c)\tThese Clauses apply with respect to the transfer of personal data as specified in Annex I.B. 该等条款适用于附件I.B.中规定的个人数据的转移。\n(d)\tThe Appendix to these Clauses containing the Annexes referred to therein forms an integral part of these Clauses. 包含附件的该等条款的附录为该等条款不可分割的一部分。\nClause 2\r#\rEffect and invariability of the Clauses 效力和条款恒定\r#\r(a)\tThese Clauses set out appropriate safeguards, including enforceable data subject rights and effective legal remedies, pursuant to Article 46(1) and Article 46(2)(c) of Regulation (EU) 2016/679 and, with respect to data transfers from controllers to processors and/or processors to processors, standard contractual clauses pursuant to Article 28(7) of Regulation (EU) 2016/679, provided they are not modified, except to select the appropriate Module(s) or to add or update information in the Appendix. This does not prevent the Parties from including the standard contractual clauses laid down in these Clauses in a wider contract and/or to add other clauses or additional safeguards, provided that they do not contradict, directly or indirectly, these Clauses or prejudice the fundamental rights or freedoms of data subjects. 该等条款规定了包括可执行的数据主体权利和有效的法律救济措施在内的适当的保障措施，其依据为根据欧盟2016/679号条例第46条第（1）项和第46条第（2）（c）项规定，就数据从控制者向处理者和/或处理者向处理者传输而言，依据为欧盟2016/679号条例第28条第（7）项规定的标准合同条款，前提为除根据附录选择适当的模块或者添加或更新信息外不做其他修改。在不直接或间接地与该等条款相矛盾或损害数据主体的基本权利或自由前提下，双方可以将标准合同条款中规定的该等条款纳入其他合同中和/或增加其他条款或额外的保障措施。\n(b)\tThese Clauses are without prejudice to obligations to which the data exporter is subject by virtue of Regulation (EU) 2016/679. 该等条款不得对数据出口方根据欧盟2016/679号条例所承担的义务造成不利影响。\nClause 3\r#\rThird-party beneficiaries 第三方受益人\r#\r(a)\tData subjects may invoke and enforce these Clauses, as third-party beneficiaries, against the data exporter and/or data importer, with the following exceptions: 数据主体可以作为第三方受益人对数据出口方和/或数据进口方援引并执行该等条款，除非： (i)\tClause 1, Clause 2, Clause 3, Clause 6, Clause 7; 第1条、第2条、第3条、第6条、第7条；\n(ii)\tClause 8.1(b), 8.9(a), (c), (d) and (e); 第8.1条第（b）项，第8.9条第（a）、（c）、（d）和（e）项；\n(iii)\tClause 9(a), (c), (d) and (e); 第9条第（a）、（c）、（d）和（e）项；\n(iv)\tClause 12(a), (d) and (f); 第12条第（a）、（d）和（f）项；\n(v)\tClause 13; 第13条；\n(vi)\tClause 15.1(c), (d) and (e); 第15.1条第（c）、（d）和（e）项；\n(vii)\tClause 16(e); 第16条第（e）项；\n(viii)\tClause 18(a) and (b);第18条第（a）和（b）项； (b)\tParagraph (a) is without prejudice to rights of data subjects under Regulation (EU) 2016/679. （a）项不影响数据主体在欧盟2016/679号条例下的权利。\nClause 4\r#\rInterpretation 解释\r#\r(a)\tWhere these Clauses use terms that are defined in Regulation (EU) 2016/679, those terms shall have the same meaning as in that Regulation. 如果该等条款使用了在欧盟2016/679号条例中定义的术语，该等术语应具有与该条例相同的含义。\n(b)\tThese Clauses shall be read and interpreted in the light of the provisions of Regulation (EU) 2016/679. 该等条款应根据欧盟2016/679号条例的规定进行理解和解释。\n(c)\tThese Clauses shall not be interpreted in a way that conflicts with rights and obligations provided for in Regulation (EU) 2016/679. 该等条款的解释不得与欧盟2016/679号条例规定的权利和义务相冲突。\nClause 5\r#\rHierarchy 效力层级\r#\rIn the event of a contradiction between these Clauses and the provisions of related agreements between the Parties, existing at the time these Clauses are agreed or entered into thereafter, these Clauses shall prevail. 如果该等条款与双方在就该等条款达成一致时存在的或随后签订的相关协议的约定相冲突，以该等条款为准。\nClause 6\r#\rDescription of the transfer(s) 转移说明\r#\rThe details of the transfer(s), and in particular the categories of personal data that are transferred and the purpose(s) for which they are transferred, are specified in Annex I.B. 移的具体事宜，尤其是转移的个人数据种类和转移目的，在附件I.B.列明。\nClause 7 – Optional\r#\rDocking clause\r#\r[intentionally left blank]\nSECTION II – OBLIGATIONS OF THE PARTIES 第二部分 - 双方的义务\r#\rClause 8\r#\rData protection safeguards 数据保护保障措施\r#\rThe data exporter warrants that it has used reasonable efforts to determine that the data importer is able, through the implementation of appropriate technical and organisational measures, to satisfy its obligations under these Clauses. 数据出口方保证，其已尽到合理努力，确定数据进口方能够通过采取适当的技术和组织措施，履行其在该等条款项下的义务。\n8.1\tInstructions 说明\r#\r(a)\tThe data importer shall process the personal data only on documented instructions from the data exporter. The data exporter may give such instructions throughout the duration of the contract. 数据进口方应仅根据数据出口方的书面指示处理个人数据。数据出口方可在整个合同期内发出此类指示。\n(b)\tThe data importer shall immediately inform the data exporter if it is unable to follow those instructions. 如果数据进口方无法遵守这些指示，应立即通知数据出口方。\n8.2\tPurpose limitation 目的限制\r#\rThe data importer shall process the personal data only for the specific purpose(s) of the transfer, as set out in Annex I. B, unless on further instructions from the data exporter. 数据进口方应仅为附件I.B.中规定的特定转让目的处理个人数据，除非根据数据出口方的进一步指示。\n8.3\tTransparency 透明度\r#\rOn request, the data exporter shall make a copy of these Clauses, including the Appendix as completed by the Parties, available to the data subject free of charge. To the extent necessary to protect business secrets or other confidential information, including the measures described in Annex II and personal data, the data exporter may redact part of the text of the Appendix to these Clauses prior to sharing a copy, but shall provide a meaningful summary where the data subject would otherwise not be able to understand the its content or exercise his/her rights. On request, the Parties shall provide the data subject with the reasons for the redactions, to the extent possible without revealing the redacted information. This Clause is without prejudice to the obligations of the data exporter under Articles 13 and 14 of Regulation (EU) 2016/679. 经请求，数据出口方应免费向数据主体提供一份该等条款的副本，包括双方所填写的附录。在保护商业秘密或其他保密信息（包括附件II中的措施和个人数据）的必要范围内，数据出口方可在分享副本之前编辑附录的部分文本，但如数据主体无法理解其内容或行使其权利时，还应提供有效的摘要。经请求，双方应在不泄露经编辑的信息的情况下，尽可能向数据主体提供编辑的理由。该等条款不影响数据出口方根据欧盟第2016/679号条例第13和14条所承担的义务。\n8.4\tAccuracy 准确性\r#\rIf the data importer becomes aware that the personal data it has received is inaccurate, or has become outdated, it shall inform the data exporter without undue delay. In this case, the data importer shall cooperate with the data exporter to erase or rectify the data. 如果数据进口方意识到它所接收的个人数据不准确或已经过时，不得无故迟延通知数据出口方。在该情形下，数据进口方应当配合数据出口方对数据进行更正或者删除。\n8.5\tDuration of processing and erasure or return of data 处理期限和数据的删除或归还\r#\rProcessing by the data importer shall only take place for the duration specified in Annex I.B. After the end of the provision of the processing services, the data importer shall, at the choice of the data exporter, delete all personal data processed on behalf of the data exporter and certify to the data exporter that it has done so, or return to the data exporter all personal data processed on its behalf and delete existing copies. Until the data is deleted or returned, the data importer shall continue to ensure compliance with these Clauses. In case of local laws applicable to the data importer that prohibit return or deletion of the personal data, the data importer warrants that it will continue to ensure compliance with these Clauses and will only process it to the extent and for as long as required under that local law. This is without prejudice to Clause 14, in particular the requirement for the data importer under Clause 14(e) to notify the data exporter throughout the duration of the contract if it has reason to believe that it is or has become subject to laws or practices not in line with the requirements under Clause 14(a). 数据进口方的处理应仅在附件I.B.中规定的期限内进行。在提供处理服务结束后，数据进口方应根据数据出口方的选择，删除代表数据出口方处理的所有个人数据，并向数据出口方证明它已这样做，或向数据出口方归还代表其处理的所有个人数据并删除现有副本。在数据被删除或归还之前，数据进口方应继续确保遵守该等条款。如果适用于数据进口方的当地法律禁止归还或删除个人数据，数据进口方保证它将继续确保遵守该等条款，并且只在当地法律规定的范围内和时间内处理这些数据。这并不影响第14条，特别是第14条第（e）项对数据进口方的要求，即如果它有理由相信它受到或已经受到不符合第14条第（a）项要求的法律或惯例的约束，则在整个合同期内通知数据出口方。\n8.6\tSecurity of processing 处理的安全性\r#\r(a)\tThe data importer and, during transmission, also the data exporter shall implement appropriate technical and organisational measures to ensure the security of the data, including protection against a breach of security leading to accidental or unlawful destruction, loss, alteration, unauthorised disclosure or access to that data (hereinafter ‘personal data breach’). In assessing the appropriate level of security, the Parties shall take due account of the state of the art, the costs of implementation, the nature, scope, context and purpose(s) of processing and the risks involved in the processing for the data subjects. The Parties shall in particular consider having recourse to encryption or pseudonymisation, including during transmission, where the purpose of processing can be fulfilled in that manner. In case of pseudonymisation, the additional information for attributing the personal data to a specific data subject shall, where possible, remain under the exclusive control of the data exporter. In complying with its obligations under this paragraph, the data importer shall at least implement the technical and organisational measures specified in Annex II. The data importer shall carry out regular checks to ensure that these measures continue to provide an appropriate level of security. 数据进口方，以及在转移过程中的数据出口方，应采取适当的技术和组织措施，以确保个人数据的安全，包括防止安全漏洞导致意外或非法的破坏、丢失、篡改、未经授权的披露或访问（以下简称“个人数据泄露”）。在评估适当的安全水平时，双方应适当考虑技术水平、实施成本、处理的性质、范围、场景和目的以及处理过程中相对于数据主体的风险。如果处理的目的可以通过这种方式实现，双方应特别考虑采用（包括在传输过程中的）加密或假名化。双方应特别考虑采用加密或假名化，包括在转移过程中，如果处理的目的可以通过这种方式实现。在假名化的情况下，在可能的情况下，用于将个人数据归属于特定数据主体的额外信息应保持在数据出口方的排他控制之下。在遵守本段规定的义务时，数据进口方应至少实施附件II中规定的技术和组织措施。数据进口方应进行定期检查，以确保这些措施持续提供适当的安全水平。\n(b)\tThe data importer shall grant access to the personal data to members of its personnel only to the extent strictly necessary for the implementation, management and monitoring of the contract. It shall ensure that persons authorised to process the personal data have committed themselves to confidentiality or are under an appropriate statutory obligation of confidentiality. 数据进口方应仅在执行、管理和监督合同所严格必要的范围内允许其工作人员访问这些数据。应确保被授权处理个人数据的人已承诺保密或负有适当的法定保密义务。\n(c)\tIn the event of a personal data breach concerning personal data processed by the data importer under these Clauses, the data importer shall take appropriate measures to address the breach, including measures to mitigate its adverse effects. The data importer shall also notify the data exporter without undue delay after having become aware of the breach. Such notification shall contain the details of a contact point where more information can be obtained, a description of the nature of the breach (including, where possible, categories and approximate number of data subjects and personal data records concerned), its likely consequences and the measures taken or proposed to address the breach including, where appropriate, measures to mitigate its possible adverse effects. Where, and in so far as, it is not possible to provide all information at the same time, the initial notification shall contain the information then available and further information shall, as it becomes available, subsequently be provided without undue delay. 如果发生涉及数据进口方根据该等条款处理的个人数据泄露事件，数据进口方应采取适当措施处理泄露事件，包括采取措施减轻其可能的不利影响。数据进口方还应在意识到泄露后，不得无故迟延通知数据出口方。该通知应当包含可获得更多信息的联络点的详细信息，对泄露性质的描述（在可能的情况下，包括有关数据主体和个人数据记录的类别和大致数量），可能的后果和为解决数据泄露而采取或建议采取的措施，包括采取措施减轻其可能的不利影响。如果当时无法提供所有信息，初步通知应当包含当时可得的信息，随后在获得进一步信息时，不得无故迟延提供。\n(d)\tThe data importer shall cooperate with and assist the data exporter to enable the data exporter to comply with its obligations under Regulation (EU) 2016/679, in particular to notify the competent supervisory authority and the affected data subjects, taking into account the nature of processing and the information available to the data importer. 数据进口方应与数据出口方合作并提供协助，使数据出口方能够遵守欧盟2016/679号条例规定的义务，特别是通知主管监管部门和受影响的数据主体，需同时考虑到处理的性质和数据进口方所掌握的信息。\n8.7\tSensitive data 敏感数据\r#\rWhere the transfer involves personal data revealing racial or ethnic origin, political opinions, religious or philosophical beliefs, or trade union membership, genetic data, or biometric data for the purpose of uniquely identifying a natural person, data concerning health or a person’s sex life or sexual orientation, or data relating to criminal convictions and offences (hereinafter ‘sensitive data’), the data importer shall apply the specific restrictions and/or additional safeguards described in Annex I.B. 如果转移涉及显示种族或民族血统、政治观点、宗教或哲学信仰或工会会员资格的个人数据、遗传数据或用于唯一识别自然人的生物识别数据、有关健康或个人性生活或性取向的数据、或与刑事定罪或犯罪有关的数据（以下简称“敏感数据”），数据进口方应根据附件I.B.中的规定采取特定限制和/或额外保障措施。\n8.8\tOnward transfers 再转移\r#\rThe data importer shall only disclose the personal data to a third party on documented instructions from the data exporter. In addition, the data may only be disclosed to a third party located outside the European Union (in the same country as the data importer or in another third country, hereinafter ‘onward transfer’) if the third party is or agrees to be bound by these Clauses, under the appropriate Module, or if: 数据进口方应仅根据数据出口方的书面指示将个人数据披露给第三方。此外，只有在第三方根据适当的模块同意受该等条款约束的情况下，数据才能披露给位于欧盟以外4的第三方（与数据进口方在同一国家或在另一个第三国，以下简称“再转移”），或者如果：\n(i)\tthe onward transfer is to a country benefitting from an adequacy decision pursuant to Article 45 of Regulation (EU) 2016/679 that covers the onward transfer; 再转移的目标国是根据欧盟2016/679号条例第45条享受充分性保护决定的国家；\n(ii)\tthe third party otherwise ensures appropriate safeguards pursuant to Articles 46 or 47 Regulation of (EU) 2016/679 with respect to the processing in question; 第三方根据欧盟2016/679号条例第46条或47条，以其他方式确保对有关处理的适当保障措施；\n(iii)\tthe onward transfer is necessary for the establishment, exercise or defence of legal claims in the context of specific administrative, regulatory or judicial proceedings; or 在特定的行政、监管或司法程序中，为建立、行使或支持权利主张所必需；或者\n(iv)\tthe onward transfer is necessary in order to protect the vital interests of the data subject or of another natural person. 为了保护数据主体或其他自然人的关键利益所必需。\nAny onward transfer is subject to compliance by the data importer with all the other safeguards under these Clauses, in particular purpose limitation. 数据进口方的任何再转移都必须遵守该等条款规定的所有其他保障措施，特别是关于目的限制的规定。\n8.9\tDocumentation and compliance 文件和合规性\r#\r(a)\tThe data importer shall promptly and adequately deal with enquiries from the data exporter that relate to the processing under these Clauses. 数据进口方应及时和充分地处理数据出口方提出的与该等条款下的处理有关的询问。\n(b)\tThe Parties shall be able to demonstrate compliance with these Clauses. In particular, the data importer shall keep appropriate documentation on the processing activities carried out on behalf of the data exporter. 双方应能证明遵守该等条款。尤其是数据进口方应保留代表数据出口方进行的处理活动的适当文件。\n(c)\tThe data importer shall make available to the data exporter all information necessary to demonstrate compliance with the obligations set out in these Clauses and at the data exporter’s request, allow for and contribute to audits of the processing activities covered by these Clauses, at reasonable intervals or if there are indications of non- compliance. In deciding on a review or audit, the data exporter may take into account relevant certifications held by the data importer. 数据进口方应向数据出口方提供所有必要的信息，以证明遵守该等条款中规定的义务，在合理的时间间隔或有不合规迹象时，应数据出口方的请求，允许并协助对该等条款所涵盖的处理活动进行审计。在决定审查或审计时，数据出口方可以考虑到数据进口方持有的相关认证。\n(d)\tThe data exporter may choose to conduct the audit by itself or mandate an independent auditor. Audits may include inspections at the premises or physical facilities of the data importer and shall, where appropriate, be carried out with reasonable notice. 数据出口方可以自愿选择自行审计，也可以委托独立审计方进行审计。审计可包括对数据进口方的场所或物理设施的检查，在适当的情况下需进行合理通知。\n(e)\tThe Parties shall make the information referred to in paragraphs (b) and (c), including the results of any audits, available to the competent supervisory authority on request. 各方应根据请求向主管监管部门提供（b）和（c）项所述的信息，包括任何审计的结果。 Clause 9 Use of sub-processors 分包处理者的作用\n(a)\tThe data importer shall not sub-contract any of its processing activities performed on behalf of the data exporter under these Clauses to a sub-processor without the data exporter’s prior specific written authorisation. The data importer shall submit the request for specific authorisation at least ? month prior to the engagement of the sub-processor, together with the information necessary to enable the data exporter to decide on the authorisation. The list of sub-processors already authorised by the data exporter can be found in Annex III. The Parties shall keep Annex III up to date. 具体的事先授权未经数据出口方事先具体书面授权，数据进口方不得将其根据该等条款代表数据出口方进行的任何处理活动分包给其他处理方。数据进口方应在聘用其他处理方之前至少？个月提交具体授权请求，同时提供必要的信息，以便数据出口方对授权作出决定。已获数据出口方授权的分包处理者名单见附件III。双方应及时更新附件III。\n(b)\tWhere the data importer engages a sub-processor to carry out specific processing activities (on behalf of the data exporter), it shall do so by way of a written contract that provides for, in substance, the same data protection obligations as those binding the data importer under these Clauses, including in terms of third-party beneficiary rights for data subjects. The Parties agree that, by complying with this Clause, the data importer fulfils its obligations under Clause 8.8. The data importer shall ensure that the sub-processor complies with the obligations to which the data importer is subject pursuant for the Clauses. 如果数据进口方聘请分包处理者（代表数据出口方）进行具体的处理活动，它应通过书面合同的方式进行，该合同实质上规定了与数据进口方在该等条款下所受约束相同的数据保护义务，包括数据主体的第三方受益人权利方面。8双方同意，通过遵守该等条款，数据进口方履行了其在第8.8条下的义务。数据进口方应确保分包处理者遵守数据进口方根据该等条款所承担的义务。\n(c)\tThe data importer shall provide, at the data exporter’s request, a copy of such a sub-processor agreement and any subsequent amendments to the data exporter. To the extent necessary to protect business secrets or other confidential information, including personal data, the data importer may redact the text of the agreement prior to sharing a copy. 应数据出口方的请求，数据进口方向数据出口方提供与该分包处理者签署的协议及任何后续修订的副本。在保护商业秘密或其他机密信息（包括个人数据）的必要范围内，数据进口方可以在分享副本之前对协议文本进行编辑。\n(d)\tThe data importer shall remain fully responsible to the data exporter for the performance of the sub-processor’s obligations under its contract with the data importer. The data importer shall notify the data exporter of any failure by the sub-processor to fulfil its obligations under that contract. 数据进口方应继续就分包处理者履行其与数据进口方合同项下的义务向数据出口方承担全部责任。数据进口方应将分包处理者未能履行其在该合同下的义务的情况通知数据出口方。\n(e)\tThe data importer shall agree a third-party beneficiary clause with the sub-processor whereby – in the event the data importer has factually disappeared, ceased to exist in law or has become insolvent – the data exporter shall have the right to terminate the sub-processor contract and to instruct the sub-processor to erase or return the personal data. 数据进口方应与分包处理者就第三方受益人条款达成一致，据此，在数据进口方事实上已经消失、在法律上不复存在或已经破产的情况下，数据出口方应有权终止分包处理者合同并指示分包处理者删除或归还个人数据。\nClause 10\r#\rData subject rights 数据主体权利\r#\r(a)\tThe data importer shall promptly notify the data exporter of any request it has received from a data subject. It shall not respond to that request itself unless it has been authorised to do so by the data exporter. 数据进口方应及时通知数据出口方它从数据主体收到的任何请求。除非得到数据出口方的授权，否则它本身不得对该请求作出回应。 (b)\tThe data importer shall assist the data exporter in fulfilling its obligations to respond to data subjects’ requests for the exercise of their rights under Regulation (EU) 2016/679. In this regard, the Parties shall set out in Annex II the appropriate technical and organisational measures, taking into account the nature of the processing, by which the assistance shall be provided, as well as the scope and the extent of the assistance required. 数据进口方应协助数据出口方履行义务，回应数据主体根据欧盟2016/679号条例行使其权利的请求。双方应据此考虑到处理的性质后在附件II中规定协助所需的适当的技术和组织措施，以及所需协助的范围和程度。\n(c)\tIn fulfilling its obligations under paragraphs (a) and (b), the data importer shall comply with the instructions from the data exporter. 在履行第（a）和第（b）项规定的义务时，数据进口方应遵守数据出口方的指示。\nClause 11\r#\rRedress 救济措施\r#\r(a)\tThe data importer shall inform data subjects in a transparent and easily accessible format, through individual notice or on its website, of a contact point authorised to handle complaints. It shall deal promptly with any complaints it receives from a data subject. 数据进口方应通过个别通知或在其网站上公告，以透明和易于获知的形式，告知数据主体授权处理投诉的联络点。它应立即处理它从数据主体收到的任何投诉。\n(b)\tIn case of a dispute between a data subject and one of the Parties as regards compliance with these Clauses, that Party shall use its best efforts to resolve the issue amicably in a timely fashion. The Parties shall keep each other informed about such disputes and, where appropriate, cooperate in resolving them. 如果数据主体与其中一方在遵守该等条款方面出现争议，该方应尽最大努力及时友好地解决问题。双方应相互通知此类争议，并在适当时合作解决这些争议。\n(c)\tWhere the data subject invokes a third-party beneficiary right pursuant to Clause 3, the data importer shall accept the decision of the data subject to: 如果数据主体根据第3条援引第三方受益权，数据进口方应接受数据主体的决定：\n(i)\tlodge a complaint with the supervisory authority in the Member State of his/her habitual residence or place of work, or the competent supervisory authority pursuant to Clause 13; 向其经常居住地或工作地点的成员国的监管机构或根据第13条规定的主管监管机构提出投诉； (ii)\trefer the dispute to the competent courts within the meaning of Clause 18. 将争端提交给第18条意义上的主管法院。\n(d)\tThe Parties accept that the data subject may be represented by a not-for-profit body, organisation or association under the conditions set out in Article 80(1) of Regulation (EU) 2016/679. 双方同意，根据欧盟2016/679号条例第80条第（1）项规定的条件，非营利性机构、组织或协会可代表数据主体行事。\n(e)\tThe data importer shall abide by a decision that is binding under the applicable EU or Member State law. 数据进口方应遵守根据适用的欧盟或成员国法律具有约束力的决定。\n(f)\tThe data importer agrees that the choice made by the data subject will not prejudice his/her substantive and procedural rights to seek remedies in accordance with applicable laws. 数据进口方同意，数据主体的选择不会损害他/她根据适用法律寻求补救的实质性和程序性权利。\nClause 12\r#\rLiability 责任\r#\r(a)\tEach Party shall be liable to the other Party/ies for any damages it causes the other Party/ies by any breach of these Clauses. 各方应对其违反任何该等条款而给另一方造成的任何损失承担责任。\n(b)\tThe data importer shall be liable to the data subject, and the data subject shall be entitled to receive compensation, for any material or non-material damages the data importer or its sub-processor causes the data subject by breaching the third-party beneficiary rights under these Clauses. 数据进口方应对数据主体承担责任，数据进口方或者其分包处理者因违反该等条款规定的第三方受益人权利而给数据主体造成任何物质或精神损失，数据主体有权获得补偿。\n(c)\tNotwithstanding paragraph (b), the data exporter shall be liable to the data subject, and the data subject shall be entitled to receive compensation, for any material or non-material damages the data exporter or the data importer (or its sub- processor) causes the data subject by breaching the third-party beneficiary rights under these Clauses. This is without prejudice to the liability of the data exporter and, where the data exporter is a processor acting on behalf of a controller, to the liability of the controller under Regulation (EU) 2016/679 or Regulation (EU) 2018/1725, as applicable. 尽管有（b）项的规定，因数据出口方或数据进口方（或其分包处理者）违反该等条款规定的第三方受益人权利而给数据主体造成任何物质或精神损失，数据出口方应向数据主体承担责任，并且数据主体有权获得赔偿。在数据出口方作为处理者代表控制者时，这不影响根据所适用的欧盟2016/679号条例或欧盟2018/1725号条例，数据出口方应当承担的责任，也不影响数据控制者应当承担的责任。\n(d)\tThe Parties agree that if the data exporter is held liable under paragraph (c) for damages caused by the data importer (or its sub-processor), it shall be entitled to claim back from the data importer that part of the compensation corresponding to the data importer’s responsibility for the damage. 双方同意，如果数据出口方根据（c）项对数据进口方（或其分包处理者）造成的损失应当承担责任，数据出口方有权就数据进口方应当承担的责任损失部分进行追偿。\n(e)\tWhere more than one Party is responsible for any damage caused to the data subject as a result of a breach of these Clauses, all responsible Parties shall be jointly and severally liable and the data subject is entitled to bring an action in court against any of these Parties. 如果有一个以上的合同方对违反任何该等条款给数据主体造成的任何损害均应承担责任，所有责任方应承担连带责任，数据主体有权选择任何一方提起司法诉讼。\n(f)\tThe Parties agree that if one Party is held liable under paragraph (e), it shall be entitled to claim back from the other Party/ies that part of the compensation corresponding to its/their responsibility for the damage. 双方同意，如果一方根据（e）项被认定为应当承担责任，其有权就其他方应当承担的责任损失部分进行追偿。\n(g)\tThe data importer may not invoke the conduct of a sub-processor to avoid its own liability. 数据进口方不得援引分包处理者的行为来规避责任。\nClause 13\r#\rSupervision 监管\r#\r(a)\tThe supervisory authority with responsibility for ensuring compliance by the data exporter with Regulation (EU) 2016/679 as regards the data transfer, as indicated in Annex I.C, shall act as competent supervisory authority. 如附件I.C所示，负责确保数据出口方在数据转移方面遵守欧盟2016/679号条例的监管机构应作为主管监管机构。\n(b)\tThe data importer agrees to submit itself to the jurisdiction of and cooperate with the competent supervisory authority in any procedures aimed at ensuring compliance with these Clauses. In particular, the data importer agrees to respond to enquiries, submit to audits and comply with the measures adopted by the supervisory authority, including remedial and compensatory measures. It shall provide the supervisory authority with written confirmation that the necessary actions have been taken. 数据进口方同意在任何旨在确保遵守该等条款的程序中服从主管监管部门的管辖并与之合作。特别是，数据进口方同意回应询问、接收审计和遵守监管部门采取的措施，包括损害赔偿和补偿措施。数据出口方应当就已经采取的必要行动以书面方式向监管部门进行确认。\nSECTION III – LOCAL LAWS AND OBLIGATIONS IN CASE OF ACCESS BY PUBLIC AUTHORITIES\r#\r第三部分 - 当地法律和公共机构访问时的义务\r#\rClause 14\r#\rLocal laws and practices affecting compliance with the Clauses 影响遵守该条款的当地法律和惯例\r#\r(a)\tThe Parties warrant that they have no reason to believe that the laws and practices in the third country of destination applicable to the processing of the personal data by the data importer, including any requirements to disclose personal data or measures authorising access by public authorities, prevent the data importer from fulfilling its obligations under these Clauses. This is based on the understanding that laws and practices that respect the essence of the fundamental rights and freedoms and do not exceed what is necessary and proportionate in a democratic society to safeguard one of the objectives listed in Article 23(1) of Regulation (EU) 2016/679, are not in contradiction with these Clauses. 双方保证，他们没有理由相信，目的地第三国适用于数据进口方处理个人数据的法律和惯例，包括披露个人数据的任何要求或授权公共当局查阅的措施，会妨碍数据进口方履行该等条款规定的义务。该理解基于该等法律和惯例与该等条款不相抵触，该等法律和惯例本质上应是尊重基本权利和自由的且该等法律和惯例没有超越民主社会为保障欧盟2016/679号条例第23条第（1）项所列目标之一的必要性和相称性。\n(b)\tThe Parties declare that in providing the warranty in paragraph (a), they have taken due account in particular of the following elements: 双方声明，在提供（a）项中的保证时，他们特别考虑到了以下因素：\n(i)\tthe specific circumstances of the transfer, including the length of the processing chain, the number of actors involved and the transmission channels used; intended onward transfers; the type of recipient; the purpose of processing; the categories and format of the transferred personal data; the economic sector in which the transfer occurs; the storage location of the data transferred; 转移的具体情况，包括处理环节的长度、涉及的行为者的数量和使用的传输渠道；预计再转移情况；接收者的类型；处理的目的；转移的个人数据的种类和格式；发生转移涉及的产业部门；转移数据的存储地点；\n(ii)\tthe laws and practices of the third country of destination– including those requiring the disclosure of data to public authorities or authorising access by such authorities – relevant in light of the specific circumstances of the transfer, and the applicable limitations and safeguards ; 与特定转让情形相关的目的地第三国的法律和惯例、适用的限制、保障措施，包括那些要求向公共当局披露数据或授权这些当局访问的法律和惯例；\n(iii)\tany relevant contractual, technical or organisational safeguards put in place to supplement the safeguards under these Clauses, including measures applied during transmission and to the processing of the personal data in the country of destination. 为补充该等条款规定的保障措施而采取的任何相关的合同、技术或组织保障措施，包括在传输过程中以及在目的地国处理个人数据时采用的措施。\n(c)\tThe data importer warrants that, in carrying out the assessment under paragraph (b), it has made its best efforts to provide the data exporter with relevant information and agrees that it will continue to cooperate with the data exporter in ensuring compliance with these Clauses. 数据进口方保证，在进行（b）项规定的评估时，它已尽最大努力向数据出口方提供相关信息，并同意它将继续与数据出口方合作，确保遵守该等条款。\n(d)\tThe Parties agree to document the assessment under paragraph (b) and make it available to the competent supervisory authority on request. 双方同意将（b）项规定的评估记录在案，并根据请求向主管监管部门提供。\n(e)\tThe data importer agrees to notify the data exporter promptly if, after having agreed to these Clauses and for the duration of the contract, it has reason to believe that it is or has become subject to laws or practices not in line with the requirements under paragraph (a), including following a change in the laws of the third country or a measure (such as a disclosure request) indicating an application of such laws in practice that is not in line with the requirements in paragraph (a). 如果在同意该等条款之后以及在合同期内，数据进口方有理由相信它受到或已经受到不符合（a）项要求的法律或惯例的约束，包括在第三国的法律发生变化或有措施（如披露要求）表明这些法律在实践中的应用不符合（a）项的要求之后，数据进口方同意立即通知数据出口方。\n(f)\tFollowing a notification pursuant to paragraph (e), or if the data exporter otherwise has reason to believe that the data importer can no longer fulfil its obligations under these Clauses, the data exporter shall promptly identify appropriate measures (e.g. technical or organisational measures to ensure security and confidentiality) to be adopted by the data exporter and/or data importer to address the situation. The data exporter shall suspend the data transfer if it considers that no appropriate safeguards for such transfer can be ensured, or if instructed by the competent supervisory authority to do so. In this case, the data exporter shall be entitled to terminate the contract, insofar as it concerns the processing of personal data under these Clauses. If the contract involves more than two Parties, the data exporter may exercise this right to termination only with respect to the relevant Party, unless the Parties have agreed otherwise. Where the contract is terminated pursuant to this Clause, Clause 16(d) and (e) shall apply. 收到根据（e）发出的通知后，或如果数据出口方有理由相信数据进口方不能再履行其在该等条款下的义务，数据出口方应立即确定数据出口方和/或数据进口方将采取的适当措施（例如，确保安全和保密的技术或组织措施），以应对该等情况。如果数据出口方认为无法确保此类转移的适当保障措施，或者如果主管监管部门指示这样做，数据出口方应暂停数据转移。在这种情况下，数据出口方应有权就涉及该等条款规定的个人数据处理事宜终止合同。如果合同涉及两个以上的合同方，数据出口方只能对相关合同方行使这一终止权，除非双方另有约定。如果合同根据该等条款被终止，则应适用第16条第（d）项和第（e）项。\nClause 15\r#\rObligations of the data importer in case of access by public authorities 数据进口方在被公共当局访问时的义务\r#\r15.1\tNotification 通知\r#\r(a)\tThe data importer agrees to notify the data exporter and, where possible, the data subject promptly (if necessary with the help of the data exporter) if it: 数据进口方同意在以下情况下立即通知数据出口方，并在可能的情况下立即通知数据主体（必要时在数据出口方的帮助下）：\n(i)\treceives a legally binding request from a public authority, including judicial authorities, under the laws of the country of destination for the disclosure of personal data transferred pursuant to these Clauses; such notification shall include information about the personal data requested, the requesting authority, the legal basis for the request and the response provided; or 收到公共当局（包括司法当局）根据目的地国法律提出的具有法律约束力的要求，要求披露根据该等条款转让的个人数据；这种通知应包括关于所要求的个人数据、提出要求的当局、提出要求的法律依据和所提供的答复的信息；或\n(ii)\tbecomes aware of any direct access by public authorities to personal data transferred pursuant to these Clauses in accordance with the laws of the country of destination; such notification shall include all information available to the importer. 意识到公共当局根据目的地国的法律对根据该等条款转让的个人数据进行任何直接访问；该等通知应包括进口方可获得的所有信息。\n(b)\tIf the data importer is prohibited from notifying the data exporter and/or the data subject under the laws of the country of destination, the data importer agrees to use its best efforts to obtain a waiver of the prohibition, with a view to communicating as much information as possible, as soon as possible. The data importer agrees to document its best efforts in order to be able to demonstrate them on request of the data exporter. 如果数据进口方根据目的地国的法律被禁止通知数据出口方和/或数据主体，数据进口方同意尽其最大努力获得禁令的豁免，以期尽快传达尽可能多的信息。数据进口方同意记录其最大的努力，以便能够在数据出口方的要求下证明这些努力。\n(c)\tWhere permissible under the laws of the country of destination, the data importer agrees to provide the data exporter, at regular intervals for the duration of the contract, with as much relevant information as possible on the requests received (in particular, number of requests, type of data requested, requesting authority/ies, whether requests have been challenged and the outcome of such challenges, etc.). 在目的地国法律允许的情况下，数据进口方同意在合同期内定期向数据出口方提供尽可能多的关于收到的请求的相关信息（特别是请求的数量、请求的数据类型、请求的主管部门、是否对请求提出质疑以及这些质疑的结果等）。\n(d)\tThe data importer agrees to preserve the information pursuant to paragraphs (a) to (c) for the duration of the contract and make it available to the competent supervisory authority on request. 数据进口方同意在合同期内保存（a）至（c）项规定的信息，并根据请求向主管监管部门提供这些信息。\n(e)\tParagraphs (a) to (c) are without prejudice to the obligation of the data importer pursuant to Clause 14(e) and Clause 16 to inform the data exporter promptly where it is unable to comply with these Clauses. （a）至（c）项不影响数据进口方根据第14条（e）条和第16条在无法遵守该等条款时立即通知数据出口方的义务。\n15.2\tReview of legality and data minimisation 对合法性和数据最小化的审查\r#\r(a)\tThe data importer agrees to review the legality of the request for disclosure, in particular whether it remains within the powers granted to the requesting public authority, and to challenge the request if, after careful assessment, it concludes that there are reasonable grounds to consider that the request is unlawful under the laws of the country of destination, applicable obligations under international law and principles of international comity. The data importer shall, under the same conditions, pursue possibilities of appeal. When challenging a request, the data importer shall seek interim measures with a view to suspending the effects of the request until the competent judicial authority has decided on its merits. It shall not disclose the personal data requested until required to do so under the applicable procedural rules. These requirements are without prejudice to the obligations of the data importer under Clause 14(e). 数据进口方同意审查披露请求的合法性，特别是它是否持续属于授予提出请求的公共当局的权力范围内，并在经过仔细评估后认为有合理理由认为根据目的地国的法律、所适用的国际法义务和国际礼让原则，该请求是非法的，则对该请求提出质疑。数据进口方应在相同条件下寻求上诉的可能性。在对请求提出质疑时，数据进口方应寻求临时措施，以期在主管司法当局对其案情作出实质性决定之前暂停请求的效力。在根据适用的程序规则要求披露之前，它不应披露所要求的个人数据。这些要求不影响第14条第（e）项规定的数据进口方的义务。\n(b)\tThe data importer agrees to document its legal assessment and any challenge to the request for disclosure and, to the extent permissible under the laws of the country of destination, make the documentation available to the data exporter. It shall also make it available to the competent supervisory authority on request. 数据进口方同意记录其法律评估和对披露请求的任何质疑，并在目的地国法律允许的范围内，向数据出口方提供这些文件。它还应根据请求向主管监管部门提供该文件。\n(c)\tThe data importer agrees to provide the minimum amount of information permissible when responding to a request for disclosure, based on a reasonable interpretation of the request. 数据进口方同意在回应披露请求时，根据对请求的合理解释，提供允许的最低数量的信息。\nSECTION IV – FINAL PROVISIONS\r#\r第五部分 - 最终条款\r#\rClause 16\r#\rNon-compliance with the Clauses and termination 无法遵守条款及终止\r#\r(a)\tThe data importer shall promptly inform the data exporter if it is unable to comply with these Clauses, for whatever reason. 如果数据进口方因任何原因无法遵守该等条款，应立即通知数据出口方。\n(b)\tIn the event that the data importer is in breach of these Clauses or unable to comply with these Clauses, the data exporter shall suspend the transfer of personal data to the data importer until compliance is again ensured or the contract is terminated. This is without prejudice to Clause 14(f). 如果数据进口方违反该等条款或无法遵守该等条款，数据出口方应暂停向数据进口方转让个人数据，直到再次确保遵守或终止合同。第14条第（f）项不受影响。\n(c)\tThe data exporter shall be entitled to terminate the contract, insofar as it concerns the processing of personal data under these Clauses, where: 在以下情况下，数据出口方有权就该等条款项下处理个人数据事宜终止合同，如果：\n(i)\tthe data exporter has suspended the transfer of personal data to the data importer pursuant to paragraph (b) and compliance with these Clauses is not restored within a reasonable time and in any event within one month of suspension; 数据出口方已根据（b）项暂停向数据进口方转移个人数据，而在合理时间（无论如何不超过暂停后1个月）内，仍未恢复遵守该等条款；\n(ii)\tthe data importer is in substantial or persistent breach of these Clauses; or 数据进口方严重或持续地违反该等条款；或\n(iii)\tthe data importer fails to comply with a binding decision of a competent court or supervisory authority regarding its obligations under these Clauses. 数据进口方未能遵守主管法院或监管部门关于其在该等条款下的义务的具有约束力的决定。\nIn these cases, it shall inform the competent supervisory authority of such non- compliance. Where the contract involves more than two Parties, the data exporter may exercise this right to termination only with respect to the relevant Party, unless the Parties have agreed otherwise. 在该等情况下，它应将这种不遵守规定的情况通知主管监管部门。如果合同涉及两个以上的合同方，除非双方另有约定，否则数据出口方只能对相关合同方行使这一终止权。\n(d)\tPersonal data that has been transferred prior to the termination of the contract pursuant to paragraph (c) shall at the choice of the data exporter immediately be returned to the data exporter or deleted in its entirety. The same shall apply to any copies of the data. The data importer shall certify the deletion of the data to the data exporter. Until the data is deleted or returned, the data importer shall continue to ensure compliance with these Clauses. In case of local laws applicable to the data importer that prohibit the return or deletion of the transferred personal data, the data importer warrants that it will continue to ensure compliance with these Clauses and will only process the data to the extent and for as long as required under that local law. 根据（c）项，在合同终止前已经转移的个人数据，应根据数据出口方的选择立即返还给数据出口方或全部删除。这也应适用于数据的任何副本。数据进口方应向数据出口方证明数据的删除。在数据被删除或归还之前，数据进口方应继续确保遵守该等条款。如果适用于数据进口方的当地法律禁止归还或删除转让的个人数据，则数据进口方保证将继续确保遵守该等条款，并仅在当地法律规定的范围内和时间内处理数据。\n(e)\tEither Party may revoke its agreement to be bound by these Clauses where (i) the European Commission adopts a decision pursuant to Article 45(3) of Regulation (EU) 2016/679 that covers the transfer of personal data to which these Clauses apply; or (ii) Regulation (EU) 2016/679 becomes part of the legal framework of the country to which the personal data is transferred. This is without prejudice to other obligations applying to the processing in question under Regulation (EU) 2016/679. 在以下情况下，任何一方均可撤销其受该等条款约束的协议：\n(i) 欧盟委员会根据欧盟2016/679号条例第45条第（3）项通过一项决定，该决定涉及该等条款适用的个人数据的转移；或(ii) 欧盟2016/679号条例成为个人数据被转移至的国家的法律框架的一部分。这不影响根据欧盟2016/679号条例适用于有关处理的其他义务。\nClause 17\r#\rGoverning law 法律适用\r#\rThese Clauses shall be governed by the law of the EU Member State in which the data exporter is established. Where such law does not allow for third-party beneficiary rights, they shall be governed by the law of another EU Member State that does allow for third-party beneficiary rights. The Parties agree that this shall be the law of France. 该等条款应受数据出口方所在的欧盟成员国的法律管辖。如果该法律不允许第三方受益人权利，则应受另一个允许第三方受益人权利的欧盟成员国的法律管辖。双方同意这将是法国的法律。\nClause 18\r#\rChoice of forum and jurisdiction 法院和管辖权的选择\r#\r(a)\tAny dispute arising from these Clauses shall be resolved by the courts of an EU Member State. 由该等条款引起的任何争议应由欧盟成员国的法院解决。\n(b)\tThe Parties agree that those shall be the courts of France. 双方同意，这些法院应是法国的法院。\n(c)\tA data subject may also bring legal proceedings against the data exporter and/or data importer before the courts of the Member State in which he/she has his/her habitual residence. 数据主体也可在其惯常居住地的成员国法院对数据出口方和/或数据进口方提起法律诉讼。\n(d)\tThe Parties agree to submit themselves to the jurisdiction of such courts. 双方同意接受这些法院的管辖。\n"}]